# How I went from no coding experience to coding for a living in one year (a guide)

tags: python, career

## Introduction

I got my degree in Cellular Biology in 2012. For five years thereafter, I worked in research labs studying diseases like Cancer, HIV and diabetes. My co-workers were awesome. I was doing cool, cutting edge science. The pay was... not great, and the career advancement opportunities were similarly underwhelming. I was looking for a change to something more lucrative, with better opportunities for advancement. I had family and friends who were software developers. They told me it was an interesting career and it paid well. So I looked into it. How can I become a coder? üë®‚Äçüî¨‚û°üë®‚Äçüíª

At the start of June, 2017 I was a lab technician at the University of Colorado, and I had no coding experience. A year later, in June of 2018, I started my first job as a full time software developer. And I've loved my new career choice ever since. In this article, I'll talk about *how* I made that career pivot, and I'll give you some ideas about how you could make a similar career pivot if it is something that interests you.

## Why become a software developer?

As I said above, I wasn't always a software developer. I transitioned into the field from the sciences, another field I really liked. But for me, making the move to software development was the best decision I ever made, and I'll never look back. Here are some of the reasons *I* like software development as a career and why transitioning your career to software development *might* be a good move for you too.

1. **The pay**: This one is obvious. We all work to make money and software developers make pretty good money. My very first junior developer role started out at $70,000 annual salary. While that starting pay isn't true for *all* junior developer roles, it's not that unusual either. And there is plenty of room for increasing your pay as you gain experience. As you learn more, you become more valuable. After 4+ years in the field, my annual salary is already in the 6-figures.
2. **Room for career growth**: This one goes alongside pay, but as you gain more experience as a software developer, you will have opportunities to advance in your career. This includes things like becoming a senior software engineer, a manager, or other higher administrative roles.
3. **In demand job**: There are a lot of companies out there looking for quality software developers. I won't lie. Getting your foot in the door at that first job can be very difficult. But once you're in and have proven yourself valuable, getting future software development jobs is not difficult.
4. **It's fun**: I think coding is fun. It's like solving little logic puzzles. And all the while you are building something really cool.
5. **It's rewarding**: You get to build cool applications that are used by real people. You get a great sense of pride when you push out that finished product and see people using it.

## Am I smart enough to code?

The short answer, **yes you are**. Before I learned to code, I thought coding was magic. Super smart people wrote complex, arcane words, and my computer did awesome things. I thought you had to go to school for years and years of intensive drudgery to learn these secrets. And even then, only geniuses could really understand it. **Wrong!** You do not have to be a genius to learn to code. You do not even have to have above-average intelligence. You do not even need to be good at math.

Ultimately, coding can be super simple. If you have a complicated problem, you'll break it down into smaller problems. To do large task `A`, I need to do smaller task `B`, `C` and `D`. And all these smaller problems come down to simple logical statements directing a computer to do things. "computer: print 'hello world'", "computer: make this word green", "computer: add these two numbers together".

Yes, at first you *will* feel out of your depth. I certainly did when I started. Everyone does at first. There is a lot to learn. But learning to code is just like learning to dance or learning to play an instrument or any other skill. You get started learning the basics. And believe me, you can learn those basics. And once you are comfortable with those, you start learning stuff that's a little more complicated. But it's not so bad now because you already know those basics. And those skills keep building until, eventually, you are solving those cool, complicated problems. But they don't seem so hard anymore. And stuff that used to seem impossibly complicated is now simple. You'll learn it in small, easy to understand and digest chunks. And as concepts layer on top of each other, and as you practice what you learn, things get easier and easier.

## The three main paths to becoming a software developer

Before we talk about how I learned to code, let's talk about the options *anyone* has to learn to code. If you are looking to transition into software development there are three main paths to achieve this goal. You could (1) **get a college computer science (CS) degree**, (2) **train with a coding bootcamp**, or (3) **self-educate**. All three routes have strong advantages and disadvantages. The best path for one person might not be the best path for someone else. We'll briefly go over some of those advantages and disadvantages. My sources for these paths include the [*Command Line Heros*](https://www.redhat.com/en/command-line-heroes){: target="_blank", rel="noopener noreferrer" } podcast episode, ["Becoming a Coder"](https://www.redhat.com/en/command-line-heroes/season-5/becoming-a-coder){: target="_blank", rel="noopener noreferrer" }, the book [*The Complete Software Developer's Career Guide*](https://simpleprogrammer.com/products/careerguide/){: target="_blank", rel="noopener noreferrer" } by John Sonmez, the [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#learning-to-code-learn-code){: target="_blank", rel="noopener noreferrer" }, [bestcolleges.com](https://www.bestcolleges.com/bootcamps/payment/bootcamp-cost/#comparison){: target="_blank", rel="noopener noreferrer" }, [thinkimpact.com](https://www.thinkimpact.com/average-college-tuition/){: target="_blank", rel="noopener noreferrer" }, and conversations I've had with other software developers and my own experiences. After this section, for the remainder of the article, we'll hone in on the route I took, **self-educating**. If that's all you're interested in, feel free to skip ahead to the next section where I talk about *how* I went about self-educating.

### College computer science (CS) degree

This is the big one. The most recent [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#learning-to-code-learn-code){: target="_blank", rel="noopener noreferrer" } found that ~62% of developers learned to code through a college or university. Formal training with a computer science or similar degree is a *very* popular route. And for good reason. Individuals who earn a CS degree gain a deep understanding of computer theory as well as a deep understanding of code fundamentals. They get a guided program with lots of resources for help. And they get that shiny diploma that employers love along with networking opportunities like career fairs and internship programs. The downside? It can be very expensive, both in terms of money and time.

Who is the college CS degree path a good fit for? This path *can* be a good fit for anyone who feels confident about going into software development who has the time and resources to go to school (or back to school). I think it is a particularly good fit for individuals with no previous college degree since having any college degree can generally give individuals an advantage over individuals without one when seeking that first job. It's also a good fit if you really want to gain a deep understanding of computer theory and computer fundamentals. It might not be a good fit if you don't have the time and money to invest four years of your life with limited to no income.

Advantages:

- **Depth and Quality**: A CS degree is going to give the greatest depth of understanding of how computers work "under the hood". Because of this, someone with a CS degree is likely to have a serious leg-up with theoretical topics and fundamental, complex topics like complex data structures, algorithms. Many employers understand that this doesn't *always* translate to the skill of writing high-quality production code in a real-world job, but in some cases it might, and in all cases it certainly doesn't hurt.
- **Guidance**: The plan is laid out before you. You know what classes you need to take to achieve the degree. You have an instructor guiding you through the topics. You have TAs and other students to go to for help when you get stuck.
- **employability**: Some employers just want that CS degree. Certain employers won't even consider candidates without a CS degree, especially without other programming experience at a real job. Having the degree makes it that much easier getting your foot in the door at a quality company.
- **networking**: Many universities offer programs to assist their students in getting into a career. This might be career fairs, internship opportunities, or clubs or forums where students have chances to meet with employers.

Disadvantages:

- **Cost**: A university education might cost anywhere from $40K to well over $100K over 4 years, depending on the University and financial aide. Software developer jobs are notoriously lucrative, so you'll definitely be able to pay this back in short order, but as with any degree, there's the risk of dropping out without getting the degree and still having that bill.
- **Time**: An average bachelor's degree takes 4 years as a full-time student. That's kind of a long time. On top of that, you **aren't working** (at least full-time) during those 4 years, so you are missing out on income during that time.

### Coding bootcamp

That same [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#learning-to-code-learn-code){: target="_blank", rel="noopener noreferrer" } found just over 10% of individuals learned to code through a coding bootcamp, but that number seems to be on an upward trend. What is a coding bootcamp? It's basically an intensive program that lasts anywhere from 4 weeks to several months where they take individuals with potentially no coding experience and teach them everything they know to be a proficient coder in real-world coding jobs. Many specialize in one coding language. They are generally much cheaper than the CS degree route and offer many of the same benefits, like set course schedules with guided classes and lots of help. They also usually help with job networking and placement so many of them have very high employment rates after graduation. However, because of their growing popularity, along with a lack of regulations for their programs, there are a subset of such coding bootcamps that are low quality and have poor job placement rates. You'll want to do thorough research of all your bootcamp options before picking the one that's right for you.

Who is the coding bootcamp path a good fit for? Overall, I think training at a coding bootcamp is a great option for *any* person wanting to transition their career into coding. It might be a good fit for you if you want to make that transition *quickly*, if you want help and accountability along the way to make sure you stick to your learning, and if you want extra help with networking to get that first job.

Advantages:

- **Time**: This is probably the fastest option to go from no coding experience to landing a coding job. Coding bootcamps can range in time from a month to a several months.
- **Full or part time**: While not as flexible as self-educating, different coding bootcamps have different time requirements. Most programs are full-time, immersive programs. However, some programs are part time, in the evenings, so you could work your day job and learn to code nights and/or weekends.
- **Cost**: Coding bootcamps are generally cheaper than going to a university. A several-month bootcamp will generally cost $10,000-$20,000. On top of that, some coding bootcamps won't charge anything until you land your first coding job. Some offer plans of no money down and with a money back guarantee if you don't find a job.
- **Guidance**: As with the CS degree, the plan is laid out before you. You have a set curriculum and a schedule. You have an instructor guiding you through the topics. You have teachers, TAs and other students to go to for help when you get stuck.
- **employability**: Some employers are sticklers for that 4-year college CS degree. But *many* employers have come around to the idea of coding bootcamps and will rank them on par with a quality CS degree when hiring new developers.
- **networking**: Coding bootcamps really want you to get a job after graduating. Most will facilitate employment networking opportunities and help you land that first job.

Disadvantages:

- **Cost**: I put this one in the advantage *and* disadvantage category. While overall, I think coding bootcamps are reasonably priced, they can't touch the low cost of self-educating. And in some cases, you might have to foot a large bill even if you *don't* land a job.
- **Inconsistent quality**: There are a lot of coding bootcamps out there that are **amazing**. üéâ But there are no real regulations around coding bootcamps, and there are also a plethora of coding bootcamps that are not very good or are even predatory. Do thorough research on any bootcamp before you sign that fine print.

### Self-education

The [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#learning-to-code-learn-code){: target="_blank", rel="noopener noreferrer" } was a little confusing to determine who self-educated without the help of a CS degree or a bootcamp, but if we assume that the 3 categories don't significantly overlap, approximately 27% of developers learned via self-education. What does it mean to self-educated? The term is a little misleading. Obviously, you're learning from *someone*. But generally that learning comes from pre-recorded material, outside of the context of a broader program. This means learning from sources like one-off online courses, books, blogs, podcasts, videos, games, challenges, documentation, other people's code, etc. There is no curriculum set for you, no teacher or TA to ask for help from, and no set of assignments. Because these things are not provided for you, if you choose this route, you'll need to get those things yourself. You'll need to design *your own* curriculum, set *your own* schedule and learning pace, *find* a network of people you can ask for help from (or muddy through yourself), and assign *yourself* topics to learn and projects to build.

Who is this path good for? For one it might be a good starting path for *anyone*. Because this path is free (or very cheap by comparison), it is very low risk. Anyone thinking about coding might at least *start* on the **self-education** path and see what this coding thing is all about. If you do, you can always *transition* to a college CS degree or bootcamp and be no worse off than when you started. It might also be a good fit for you if you need to keep a full-time job and want to learn coding on the side at times that fit *your* schedule and that match *your* learning pace. While learning on your own schedule at your own pace can be one of the greatest *advantages* of self-educating for some, it can be a huge *disadvantage* for others. It means (1) you have to figure out a curriculum and schedule to get from where you are to where you want to be (not easy when you don't yet know what it is you need to learn), and (2) you have to keep *yourself* accountable to stick that curriculum and schedule. With no one holding you accountable, you might struggle to find the motivation to stay on course. All that is to say, **self-educating** might not be the best fit for you if you need extra help finding your learning path staying accountable to it. It also might not be the best fit for you if you find yourself needing lots of extra help from an authority figure or if you just don't like going it alone.

Advantages:

- **Cost**: This is the cheapest option by far. Costs can range from 100% *free* to a few hundred dollars depending on the resources you opt to use. Because costs are so low, this option is also very low risk. There's virtually no financial fallout starting this path and then later on deciding coding isn't for you.
- **Flexibility**: Learn on your own schedule and at your own pace. This is a massive advantage if you can't afford to quit your job to go to school or attend a coding bootcamp.

Disadvantages:

- **lack of networking**: There's no institution networking with companies on your behalf. You'll have to put in extra work to do the networking yourself.
- **Lack of guidance**: There's no one to tell you what to do and to make sure you're doing it right. You'll need to set your own curriculum, check your own work, and seek out your own network of people to ask for help from.
- **Lack of accountability**: There's no one making you do your work. If you aren't feeling motivated, you won't do the work you need to do to get to where you want to go.
- **More to prove**: I put this in the disadvantage category because *some* employers will be skeptical of the quality of self-educated individuals, especially for that first time job. Some won't even consider an individual who doesn't have a CS degree or bootcamp certificate. However, increasingly, more and more employers are becoming open to hiring individuals with no formal training as long as they can prove they know their stuff. Some even think it show chutzpah to not need any hand-holding to get to this level. Either way, you'll have to work a little harder to prove to that first employer that you're a good fit for the job.

### Education path conclusions

Those are the three main paths you can take to go from no coding experience to landing your first coding job. All paths are quite viable and there is no one *best* path. You'll have to decide what sounds best *for you*. There are serious advantages and disadvantages to each path, and you should do more research beyond this article before picking any one path. *I* chose the **self-education** path. It worked out well for me, but it was not easy. There was a lot of difficulty and uncertainty along the way. That **self-education** path is the path  we'll be talking about for the rest of this article. But even if you chose another path, I think some of the topics we'll discuss might be nice supplements to your coding education journey. And as I mentioned above. You can always *start* down the **self-education** path, and then transition to another path later on.

## Choosing a language

When it comes to coding, everyone has their favorite language. That makes sense. The language is the thing you use to *express* what it is you want the computer to do. And it's the thing you're working with for hours on end. You want to like it. And there are a *lot* of languages to choose from. Without knowing anything about them, how are you suppose to choose one that is right for *you*?

### Think about language popularity

Okay, just pick a language. But what even are my choices? I recommend picking one of the more popular languages. The more popular a language is, the more likely it is to have a big community to support you (think more courses, tutorials, and people to talk to). These are the top 10 most popular languages according to the [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#most-popular-technologies-language){: target="_blank", rel="noopener noreferrer" }. I pruned the actual list, removing languages that are more helper languages than full-fledged programming languages. The percentage attached is the percentage of respondents who use that language (out of over 70,000 respondents). Any language on this list would be a great choice for a first programming language in terms of popularity. Even if a language you're interested in *isn't* on this list, it still probably has a great community of support and would be a fine pick for a first language.

1. JavaScript (65%)
2. Python (48%)
3. Java (33%)
4. C# (28%)
5. C++ (23%)
6. PHP (20%)
7. C (19%)
8. Go (11%)
9. Rust (9%)
10. Kotlin (9%)

### Consider how easy it is to learn

One thing you might consider when picking a language is how easy that language is to learn. All languages aren't that bad once you get to know them. But some just seem to be easier out the gate. Maybe their syntax is more straightforward, their coding style is simpler, or they do more for you so you have less to think about. What makes a coding language "easy" and which languages are easy to learn vs which languages are hard to learn is *very* subject. Here's a list from [codingdogo.com](https://www.codingdojo.com/blog/easiest-programming-language-to-learn){: target="_blank", rel="noopener noreferrer" } for their picks of the top 5 easiest and top 5 hardest languages to learn. While I have only used a couple of the languages on this list, I tend to think these choices are reasonable from my limited experience and from talking to other developers. For *why* the site thinks these are easier and more difficult languages, you'll have to [read their article](https://www.codingdojo.com/blog/easiest-programming-language-to-learn){: target="_blank", rel="noopener noreferrer" }.

Top 5 easiest to learn

1. Python
2. C
3. Ruby
4. Java
5. JavaScript

Top 5 hardest to learn

1. C++
2. Prolog
3. LISP
4. Haskell
5. Malbolge

### Consider language use case

If you have an idea of what *type* of programming you want to do, you might pick a language that is well suited for that job. Certain languages tend to be well suited for certain programming needs. Here's a list of some common programming needs, and languages that are well suited for them. This is another subjective area. Some people might consider other languages better for these jobs than the ones I chose. If that's you, or if your favorite language for a job isn't on my list, don't hate. üòõ I'm sure that's an awesome choice too.

**Front-end web development (code running in your browser):**

- **JavaScript**: This is basically the only language in town for this job alongside its spinoffs like **typescript** and its helper languages **HTML** and **CSS**.

**Back-end web development (code running on a website server):**

- **Node.js**: This language is basically the same as **javascript** with some subtle differences that allow it to run on a server. This is nice because then you can learn just one language for both front-end and back-end web development (ie full-stack web development).
- **Python**: There are tons of great web development frameworks that make Python an easy and excellent choice for web development. I'm a little biased because this is *my* language of choice.
- **PHP**: A veteran of the backend web space with a lot of web frameworks and large community.
- **C#**: The Microsoft programming language has a great community and great, opinionated backend frameworks.

**Data Science:**

- **Python**: The most popular data-science choice these days. Has great frameworks for easily processing large datasets and for data visualization. Is fast for these purposes (because they are written in **C** under the hood). Is the only choice if using certain machine learning frameworks.
- **R**: A language who's main purpose *is* data science. It is older in the data science community and quite popular in that community.

**Android development:**

- **Kotlin**: Google switched to Kotlin as the official language for Android app programming in 2017. It's simpler than Java with extensive libraries for Android development.
- **Java**: The original official Android app programming language. Is an extremely established language with a huge community.

**iOS development:**

- **Swift**: Apple launched Swift in 2014 specifically for iOS development and it has been growing in popularity ever since.
- **Objective-C**: The original iOS language. Still widely used, especially in older, established applications.

**Video game development:**

- **C++**: A very *fast* language, popular in creating game engines as well as games themselves.
- **C#**: A higher level language that is extremely popular in video game scripting.
- **JavaScript**: Very popular in creating games that are hosted in web browsers as well as on mobile platforms.
- **Java**: A versatile language that is popular in a range of games including Minecraft.

**Embedded systems and IoT:**

- **C++**: It is a fairly low-level language, with good libraries support that make it popular language for embedded systems, and it is *fast* when written well.
- **C**: A low level language that is extremely *fast* and is the language beneath the hood for many other languages like **python**. Many embedded systems are written directly in **C**.
- **Python**: with the advent of sub-languages like **micropython** that make python smaller and fit well with embedded systems, python has growing popularity in the embedded systems space, especially because it is often considered an easier language to work with than **C++** or **C**.

### Just pick one and stick with it for a while

Here's the biggest secret when it comes to picking your first language. **It really doesn't matter all that much which language you choose first.** All the languages out there (at least the more popular ones) are pretty good. And in the end, they all do pretty similar things. For the most part, they all have the same components: **grammar**, **types**, **variables**, **loops**, **conditional statements**, **functions** (if you don't know any of those terms, don't worry about it, there's plenty of time to learn üòâ). There are some differences in language components and structure (for example object oriented languages vs functional languages). But mostly the differences come down to grammar subtleties and external helper libraries available to the language. For the most part, **once you learn one language, it becomes very easy to learn a a second language**, and easier still to learn a third.

So don't stress too hard about that first language choice. The most important thing you are learning when first learning to code is how to use those underlying components (the **variables**, **loops**, etc.) that all languages have anyways. My one recommendation is to stick to that first language for a while -- at least until you feel comfortable writing in it. Finish a course in it, create a project in it. Switching away from that first language too early will just distract you from learning those core concepts common to all programming languages that are the important things to learn.

### Language choice conclusions

To conclude, **any** of the above-listed languages would make a great choice as a first programming language. There are plenty of job opportunities for any of the above-listed languages, especially as remote work becomes more popular. Things to consider include the language popularity and what you want to use it for. But in the end, the choice really doesn't matter as much as you think it does. Just pick one and stick to it so you can learn the underlying tools common to all programming languages. It'll be easy enough to switch languages later on, once you understand the fundamentals common to all programming languages.

I picked Python. It is very popular and pretty-to-look at with a simple-to-learn style. It can handle really complex projects, has a wide range of jobs it's good at, and has a really great community. But you might choose JavaScript because you want to learn how to make awesome front-end web applications, or you might choose Swift because you are really interested in making iphone apps. Just do a little research and pick one. And whatever you choose, don't stress. They're all good, and you can always change later on.

## Getting started

Okay, you've decided you are going to start your coding **self-education** journey, and you've picked a programming language. Where do we go from there? The options are overwhelming, how do you even get started? My best advice here is, **just do *something***.

It is *really* hard to know what learning path is right for you when you are first getting started. So I recommend just code *something* to start learning what is right for you. The more you code, the more you'll learn what works for you. You're never going to have a perfect lesson plan out the gate. Promise yourself right now, "I'm going to spend an hour coding on *X* platform." It doesn't really matter what resource you are using to code with. The hardest part is just breaking that deadlock in your mind and deciding you're going to code *something*. Code for an hour. At the end of that hour, re-evaluate. Maybe you decide to keep doing what you were doing -- the course you are taking or the coding game you are playing is interesting and you want to keep exploring it. Then check in after another hour. Maybe you decide to take a break today, but tomorrow, for your next coding hour, you have something new to research based on what you learned coding during that hour. It's cheesy but true: "A journey of a thousand miles begins with a single step." Take that first step and every step thereafter will be easier.

Start doing *something*? Teddy, that's pretty vague. Do you have any suggestions that are more specific? Sure. Here are a few resources that might be a nice get-your-toes-wet introduction to coding.

- [Codecademy](https://www.codecademy.com/learn){: target="_blank", rel="noopener noreferrer" }: This is a cool website that offers coding classes in the browser. You can take interactive courses in languages like **Python**, **JavaScript**, **Java** and a variety of others. Create a free account, pick a language, and start taking that introductory class.
- [FreeCodeCamp](https://www.freecodecamp.org/learn){: target="_blank", rel="noopener noreferrer" }: This is another, similar awesome website that offers a variety of free interactive courses you can take directly on their website.
- [Code Combat](https://codecombat.com/){: target="_blank", rel="noopener noreferrer" }: Video games more your speed? This is an awesome website where you learn to code while playing a dungeon crawler video game. Type code commands in order to move your hero through perilous dungeons and slay your foes.
- [General Assembly course](https://dash.generalassemb.ly/){: target="_blank", rel="noopener noreferrer" }: General Assembly is a company that offers courses, many of which are live, most of which cost money. However they have a really nice introduction to web development course that is on-demand and free.

Those are just a couple resources that I've tried out, and that I think are perfect for getting your feet wet with programming. And you don't have to finish any of them to get value. Just starting an interactive course or game will get you started on that path to learning and will get you excited to learn more! It'll give you more information about what steps you really need to take along your coding journey.

## Make yourself a learning game plan

You did it, you coded *something*! üéâ Congratulations! Even if it is an hour (even if its 15 minutes) taking an interactive class or playing a coding video game, getting started coding *something* is honestly one of the hardest and most important mental hurdles to get through and it's worth being proud of. So give yourself a pat on the back. Feel free to linger on that step. Finish that course or coding video game if you like. It's worth it. Once you're ready, lets get down to making a game plan (a learning curriculum) for the longer journey ahead. Our end goal? Become a proficient coder and get hired as a junior developer.

That curriculum is going to look different for everyone. It's going to depend on what area you want to go into (web development, smartphone app development, data science, etc.). It's going to depend on what coding language you choose (Python, JavaScript, C#, etc.). It's going to depend on your learning style (do you prefer online courses, reading books, etc.) -- I recommend trying a combination of styles. And it's going to depend on what pace you feel comfortable with (some topics might be easy, others might require lingering on until you really get them).

Below I'll list some considerations you should consider as you design a game plan.

### Keep it fluid

At first, try writing a very broad outline of the step you need to take to get from where you are now, to where you want to be (presumably hired as a junior developer). Write these high-level goals in a google doc or spreadsheet. It doesn't need to be very detailed at first. Then as you move forward fill in the details. The start of that game plan should be more detailed than the end. As you learn more, keep updating the plan. At first, your not going to know what all you need to learn to achieve your end goals. As you learn new concepts, check back on your game plan and update it to fit your new mental model.

### Have achievable, measurable goals and timelines

Try to be as specific as possible when writing your goals, especially the ones that you want to achieve in the near future. Each goal should be achievable and measurable. For example, "Complete *X* Udemy course", or "Finish reading *Y* book", or "Finish *Z* project and present it to my family". Then attach timelines to those goals. For example, "Complete *X* Udemy course by September 1st", "Finish reading *Y* book by October 1st", "Finish *Z* project and present it to my family by December 1st". By setting achievable, measurable goals, your setting setting yourself up for success in making progress on those goals. By setting achievable timelines for your goals, you're helping to motivate yourself to get those goals done in a timely manner.

### Break down bigger goals into smaller goals in your schedule

Either in the same "Game plan" document, or in a daily schedule, break down your goals into daily goals. From our goal "Complete *X* Udemy course" we might break down a daily goal of, "Complete sections 'A' and 'B' of *X* Udemy course". For goal "Finish reading *Y* book" we might break down to a daily goal of "read chapters 'A', 'B' and 'C' of book *Y*". For goal "Finish *Z* project and present it to my family", we might break down to a daily goal of "Write the game logic for making the enemies chase our hero" (that one got more specific than the other examples üòÜ). Try to check off these daily goals every day. Leave room rest days where you don't have to code anything, or make some days heavy coding days and others light coding days. Then at the end of each week take time to examine how you did this week. Were you good about accomplishing your daily goals? Are you on track for you big-picture goals? Adjust accordingly.

## Learn by doing

This is very important. The best way to learn to code (and many other things in life) is through doing it yourself. **"Practice, practice, practice!"** Later on we'll talk about some specific resources to learn with. The resources include courses and books. When you are using these resources **type the code out yourself, line by line**. It is possible to read an entire coding book or take an entire course without writing *any* code yourself. **Don't do that!** You will learn the topics 10X better if you are writing the code yourself.

When an instructor is coding, do not just watch the video! **Code along with them.** Type what they are typing into your own file and run the code yourself. Pause the video and make changes to that code. See how the tweaks you make change the output. If an instructor offers coding assignments, do those. Do not just watch the solutions afterwards. After completing a course, create a small project that uses what you learned in that course.

When reading a programming book, **write out the code yourself**. There might be times you are reading where you don't have access to a computer. That's okay. Later on, when you do have access to a computer, write code that uses what you learned from the book. Copy and run examples from the book. Tweak examples and see how the output changes. Create a small script or project that uses concepts taught in the book.

Writing your own code while taking a course or reading a book *will* slow down that course or book. *That is okay!* It's worth it. The upfront cost of taking the time to write out the code yourself will pay off immensely in terms of how well you retain what you learned in that book or course. And creating scripts and side projects outside of the context of a course will also pay off immensely in terms of your understanding of code.

## Learn these important topics

What kinds of things should you include in your learning game plan? In the next few sections I'll talk about some of the things you should probably have in any game plan, regardless of language and area of interest you want to pursue. First, some topics that are important for any developer.

### Hello World

The first thing you'll need to learn when learning any programming language is "Hello World". Basically, you need to learn how to make the simplest code possible that outputs something. Typically, teachers will have you print to the screen the words "Hello World". This is your introduction to your new coding language. If you went through [getting started](#getting-started) above, you probably already wrote your "Hello world" code. Congratulations, check that one off the list! üòÉ

### Your language's core components

When learning your first language, you'll need to learn your languages core components. These are things that basically all programming languages have in common (give or take some minor variations). I'll list some of those core components below. Obviously, if you are new to programming, you won't know any of these yet. But they are not so difficult to learn. Luckily, if you are taking a course or reading a book meant to teach your language to beginners, that course or book should always go over what these components are and how to use them with your language of choice. Soon you will be an expert at wielding these core components to get a computer to do tasks for you. The core components include:

- **Variables**: These are words that store information so that it can be used later on.
- **Data types**: These are *what* type of data is stored. They include things like numbers, word or phrases (called strings in coding), "true" or "false" key words (called booleans in coding), and more complex types in the form of data structures.
- **Operators**: These are things like `+`, `-`, `x`, `>`, `<` that can be used to compare and manipulate data.
- **Data structures**: These are *how* complex data is stored. These are things like ("lists" or "arrays"), "sets", ("dictionaries", "maps", or "hashes"), ("objects" or "structs"), and many others. Different data structures are optimal for solving different problems.
- **Control flow**: These are things like "if/else/then" statements and "loops" that are used to direct the flow of logic for a program.
- **Functions**: These are ways to store chunks of code so that the code can be re-used without having to be re-written.
- **Classes**: Not all programming languages have classes. They are specific to **object oriented** programming languages. But even if your language-of-choice doesn't use them, they are worth learning about.

### Object oriented, procedural, and functional designs

There are three main designs (or styles) of coding. Certain languages require one of these coding styles. Others can use a combination of styles based on preference. I'll go over them briefly, but you should dive deeper into these topics in your studies. If these explanations don't make sense now, that's okay. They will make more sense when you learn them for real on your coding journey.

- **Object-oriented**: In this style of coding, all things are "objects". Objects are created by initializing a class. For example we could have an "Animal" class. We would use this "Animal" class to initialize an animal object. This might look like `tigger = Animal()`. Here, my cat "tigger" is an "object" that came from the `Animal` class. He might have "attributes" associated with him like `tigger.has_fur` which would be `true`. And he might have "methods" associated with him like `talk()` which might do something like print "meow" to the screen.
- **Functional**: In this style of coding, there are usually no classes or objects. Instead, data is passed from function to function until a goal is achieved.
- **Procedural**: In this style of programming, the code is written and run top-to-bottom without including functions or classes. This is a more primitive coding style, but it can still be useful, especially in very small scripts.

### Advanced topics

Here are a few advanced topics that you will probably want to learn about on your coding journey, along with a very brief description of them. You might not need to understand *all* of these topics on a deep level, but you should at least understand all of them at surface-level, and some you might choose to deep-dive into.

- **Recursion**: These are instances where functions call themselves
- **Pointers**: These are things that "point" to the place in your computer's physical memory space where a variable or object from your code resides.
- **Memory management**: How do you handle your the memory your code uses. Some languages do this for you, others make you do it yourself.
- **Asynchronous code**: This is code that does more than one thing at the same time (sort of).
- **Cybersecurity**: How to write safe and secure code.

### Peripheral topics

There are peripheral topics that are important to learn based on your area of coding you want to go into. Here are some topics you might want to have a firm understanding of early on in your coding journey.

- **How binary works**: Learn how the binary system works and why it's so important to computer programming.
- **IP Address assignment**: Learn what your computer's IP address is and how it gets assigned.
- **how the internet works**: Learn what happens when you hit "send" on a web page form. Where does your data go, how does it get there, how does it a response back?

### Source control (or version control)

Let's say you're writing code for a website. When you write your your code, you save the files to your hard drive. Now let's say you make some changes to those files, adding in a new feature. You write your changes, and then save your files again *overwriting* those old files. But shoot, when we deploy the changes, the website is now broken. You want to go back to the previous version of the website where things were working, but you can't because you overwrote those old files. Now you have to spend a bunch of time trying to figure out how things were when your website worked, all the while your website continues to be offline. This is a problem.

One solution is to save a different file for each change. Maybe we have `my_website_1` and the next change you make `my_website_2`. That way if `my_website_2` breaks the website, we can fall back to `my_website_1`. But now we are accumulating a bunch of files that we need to keep track of. And let's say someone else takes the code because they want to make changes as well. But their changes conflict with your changes. Now who's `my_website` file do we use? This system becomes a mess very quickly.

Source control (also called version control) solves this problem. There are a few source control systems, but the main one used today is called "git". How does it work? Basically, code gets stored in a central "repository". When someone wants to make changes, they pull that code down to their own system. They make their changes locally, and then they push their local changes up to the central "repository". The updates that were pushed up to the central "repository" become the version that is used. That repository (and a repository on your local system) also keep track of the history of all the changes that have been made to it since it was created, making it easy to go back to a previous version. Also, if multiple people are working on the same code, git has mechanism for merging together two sets of code that have both made changes.

Version control will be a super important tool in your tool belt as a developer. I recommend learning the basics of how to use git very early in your coding journey. Git can be complicated for edge use cases, but the basics are really simple to learn. Then store all of your code in the cloud in a git repository. The main, cloud git repository is called [GitHub](https://github.com/){: target="_blank", rel="noopener noreferrer" }. Make yourself a GitHub account and start pushing all the code you work on up to repositories associated with your GitHub account. You can choose to make those repositories public or private. The added benefit of having all your code in GitHub, is that later on, when you want to share your code with others (say a potential employer), you can just point them to your GitHub account to look at all your cool projects. For reference to what that looks like, [check out *my* GitHub account](https://github.com/VerdantFox){: target="_blank", rel="noopener noreferrer" } where you can see a bunch of code that I've written and stored in public GitHub repositories. [I even store these blog posts in a public repository.](https://github.com/VerdantFox/blog_posts){: target="_blank", rel="noopener noreferrer" }

### (Automated) Testing

As you write your code, you're going to want to test it. The first type of testing you will learn (out of necessity) is manual testing. It works like this: run your code and observe the output. Did the test do what you wanted it to do? If not, tweak it. Then repeat. Manual testing will always be an important step in your coding process. *Automated* testing is when you write a test file that runs your code and then checks the results *for you* to make sure the code is doing what you expect it to do.

Why are automated tests important?

1. Once they are in place, automated tests reduce your workload *a lot*. There are so many things to check when running your code. You are going to want to check how your code runs with a bunch of different inputs, and edge cases. If you are only testing manually, *first* you have to remember all those inputs and edge cases, *then* you have to input them by hand, and  *then* visually observe that the results are as you expect. Ultimately it is much faster to write those tests once, so you don't have to re-do that work over-and-over.
2. Your code changes in one area might have unintended consequences for other parts of your code base. The tests that you wrote for one part of the code base will quickly uncover bugs from changes made elsewhere, even if you forget to manually test that other part of your code base.
3. Testable code is clean code. Writing tests will force you to write your code in a way that you can easily test it. This usually means that you write code that is broken up into smaller pieces that is easier to read and maintain.

Learning to write automated tests is an important skill in modern coding. It will make your code so much more reliable, and it will make changing your code later so much faster because you can rely on your automated tests to catch your bugs. And you know what? I personally know of a lot of projects that don't have any automated tests. That means that by knowing this valuable skill yourself, you will have an edge over your competitors that don't have this skill when seeking a job.

### Database basics

Most programming applications have to store data. They might store data about their users, their product, and a whole host of other things. The most efficient way to store and retrieve most types of data is in a database. There are two broad categories of databases you might want to know about: *relational databases* and *non-relational databases*.

#### Relational Database

Relational databases are the most popular type of database. They consist of **tables** that store data in a **tabular format**. This basically means that the data is stored in **rows** and **columns**, much like an Excel or Google Sheets' spreadsheet. Tables with related data can be linked to one another. For example a `products` table could be linked to a `reviews` table if the `reviews` table has a column `product_id` with an id that matched the `id` column of a specific product (row) in the `products` table. This relationship between tables is the **relational** part of **relational databases**.

Coders can interact with these **relational databases** with a language called SQL, or Structured Query Language. SQL allows coders to **query** the database to retrieve rows from those tables or to add new rows, update existing rows, or delete rows. Because SQL is the main way to interact with **relational databases**, they are sometimes refereed to as **SQL databases**.  And because these databases are so popular, the ability to write SQL code is a very valuable skill to pick up. You should learn the basics of how **relational databases** work and how to read and write some basic SQL code. You don't need to be an expert in SQL or relational databases to use the databases or to get hired, but it is important to at least learn the basics.

#### Non-relational databases

Some data doesn't easily fit into rows and columns in neat tables. This type of data can still be stored in a database, but it might be stored in a **non-relational database**. Side-note, because SQL is so ubiquitous when talking about databases, **non-relational databases** are also often referred to as **NoSQL databases**. Instead of storing data in a **table** structure, data is stored in a **document** structure. One of the most popular **non-relational databases** out there is **MongoDB**. It stores data in **documents** that look like JavaScript objects. If that's gibberish to you right now, that's okay. The documents can be queried with a language specific to MongoDB. Another fun fact, this website stores its data in a MongoDB database, including the blog post you are reading now. üòâ

Because **non-relational** databases are so much less popular overall than **relational databases**, I rank learning them as a nice skill to have but unnecessary. Look into **non-relational databases** if it is a topic that interests you in your coding journey. Otherwise, just keep in mind that they exist and move on.

### A framework or tech stack

Every language has a set of tools that are bundled up nicely to make a given job easier and more efficient. These efficiency tool bundles are called frameworks (or sometimes libraries). A series of frameworks working together to make a problem easier to solve is called a tech stack. Let's take an example from web development. Both the front-end code (the code running in the users's browser) and the back-end code (the code running on the web server) probably uses a framework.

The front end code is probably written in JavaScript. That JavaScript code might be using the [react](https://reactjs.org/) **framework** which has high level tools for creating and keeping track of front end components and the state of web page so you don't have to write those low-level complicated bits yourself. The back-end code might be written in Python and it might use the [django](https://www.djangoproject.com/) web **framework** that provides tools for accepting a web request, routing the requests to the relevant back-end code, and returning an appropriate response. And the website might store its data in a [Postgres](https://www.postgresql.org/) relational database. Together, the react front-end framework, the django back-end framework and the Postgres database could be considered the website's "tech stack".

It is a good idea to pick a framework for your language to do what it is you want to do and learn it really well. Picking a framework is similar to picking a coding language. You'll want to keep in mind how popular frameworks are that you are considering and what they are good for. But also like picking a programming language, picking the "right" framework is not as important of a decision as you might think. Most popular frameworks have a great community, documentation and job opportunities associated with them. And once you understand one framework really well, it becomes easy to pick up another one.

So pick a framework for your job and pick out all the other tools and frameworks you need to make up your "tech stack" and learn each framework and tool in the tech stack really well. Use that tech stack to make a large ["capstone project"](#build-a-capstone-project) (more on capstone projects later). This will be a key component in your quest to get hired.

### Packaging and deploying to production

When you are learning and writing code for a major skill focus area like web development or android/iOS development or game development, you will be writing that code in a development environment. You'll have your code files showing. You'll have your language and helper dependencies all installed on your machine. You'll probably type a command in your terminal to run your code *on your machine*. But now you need to give that code or product to someone else. You aren't going to tell your product users to "install python, then install these dependency packages, then open a terminal and type `run my_app.py`". You're going to want to give them or point them to the finished product. For a game that might mean giving them an executable file so that all they have to do is double-click that file and your game starts up. For a website that will mean, hosting your website on a server so that they can reach it by typing in your website's URL.

You are going to need to learn *how* to package up your code and deploy that code to an environment for your users to consume. This is an important skill to learn and one that potential employers will surely ask you about.

### Collaboration methodologies

Since you chose the **self-education** learning path you might be mostly going it alone. But once you get hired on at a job, you will working as a team. Give yourself a head start (and sound more knowledgeable to your employers) by learning about some of the collaboration methodologies. I'm going to list the most important ones below. Somewhere along your learning journey, google these methodologies and read through some wikipedia articles for how they work.

- **waterfall**
- **agile**
- **kanban**
- **scrum**

## Learn how to debug and how to handle failure

Inevitably, the code you write is going to fail to do what you want it to do. This will happen **a lot**. Like **A LOT, A LOT**. These code failures are called "bugs". The code might just give you an error or it might run successfully, but not output what you expected. In either case, you are going to want to get good at **debugging**. This is one skill that just gets easier the more experience you have. Early on in your coding journey, you are going to run into a code bug that you cannot figure out the answer to **for hours**. This is okay, do not let the bug defeat you! (that's what the bugs want üêõüòÜ) The answer might be as simple as a missing semi-colon. And there is no better feeling in the world than finally solving that pesky bug that has been plaguing you for hours. üéâ There are things you can do to help you push through the debugging process including the following.

- **google it**: Googling is possibly the most important skill to learn well as a programmer. Often times you can solve your problem by simply typing it into google and click the first link in the results. If you have a confusing error returned to you, try copy/pasting that error into google. You might find your answer quickly.
- **rubber ducking**: Explain the code out loud to an inanimate object (such as a rubber duck). Oftentimes explaining the code out loud will lead you to find the source of the problem.
- **ask for help**: If you have a friend or mentor or study buddy you can show the problem to, great! Oftentimes, someone else coming at the problem from another perspective can figure it out quickly. If you don't have someone you can show the code to, try posting your code with an explanation of the problem to [stack overflow](https://stackoverflow.com/). Perhaps a stranger can help.
- **write print statements**: One helpful tool when debugging is to add print or log statements near where the error occurred. You might print out nearby variables to see if they contain the values you expect them to.
- **use a debugger**: Learning to use a "debugger" to can be very helpful in solving tricky bugs. It is a tool that you can use to step through your code slowly, line-by-line and see information about all the surrounding variables on any given line.

## Get good at googling

I briefly touched on this when discussing debugging above, but Google (or your search engine of choice) is going to be your best friend as a developer. I search for things **constantly** every single day.

- I have an error in my code? "Copy/paste" the error into google because someone else has probably also had that same problem.
- I don't have an error, but my code isn't doing what I expect it to do? Type that problem into google. Again, someone else has probably had a similar problem and you can quickly find a solution.
- I don't know how to use a library I need for my project? Google that library and read the documentation on how to use it.
- I don't even know what library I might need to solve my problem? Google the problem I'm trying to solve and there's probably a good suggestion for which library to use.
- I forgot how to structure the syntax of some code component? Google that problem. There will be a short tutorial answering your question.
- I want to figure out what is the best web framework for my use case? Google that exact question and read blog posts comparing the top web frameworks.

Learning how to google is an invaluable skill. With practice you'll get better at framing your questions to get the results you want. Any problem or question you have, first reach to google because the answer is probably in the first few links. Only once you have exhausted your google searching should you reach out for help by posting your question in a forum like "stack overflow" or in your social media group.

## Find a mentor

This one is not a "must" in your coding journey, but it is definitely helpful. Find someone to talk to who has already done all this and made it out the other side. It can be very nice to get the perspective of someone in the field, especially if they are in the area of software development that you want to get into (ie web development, phone app development, game development, etc.). Show them your "learning game plan" and see if they have any tips for additions or alterations. Set up regular meetings to check in with them to keep yourself on track. This has the added benefit of giving yourself some accountability. "I don't want to disappoint my mentor by not putting in the work." And finally, ask them for help if you are ever really stuck on a problem.

## Immerse yourself in the jargon

There is a lot of jargon in the software world. 

## Build a capstone project

## Write a blog

## Start career networking

## An example curriculum (what I did)


## Career networking

## Resume preparation
## Interviewing skills

## Self-education resources

## Conclusions

