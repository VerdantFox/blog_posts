# How I went from no coding experience to coding for a living in one year (a guide)

tags: Python, career

## Introduction

I got my degree in Cellular Biology in 2012. I worked in research labs for the next five years studying diseases like cancer, HIV, and diabetes. My co-workers were awesome. I was doing cool, cutting-edge science. The pay was... not great, and the career advancement opportunities were similarly underwhelming. I was looking for a change to something more lucrative, with better opportunities for advancement. I had family and friends who were software developers. They told me it was an exciting career, and it paid well. So I looked into it. How can I become a coder? üë®‚Äçüî¨‚û°üë®‚Äçüíª

At the start of June 2017, I was a lab technician at the University of Colorado and had no coding experience. A year later, in June of 2018, I started my first job as a full-time software developer. And I've loved my new career choice ever since. In this article, I'll talk about *how* I made that career pivot, and I'll give you some ideas about how you could make a similar career pivot if it interests you.

## Why become a software developer?

As I said above, I wasn't always a software developer. I transitioned into the field from the sciences, another area I enjoyed. But moving to software development was the best decision I ever made, and I'll never look back. Here are some reasons *I* like software development as a career and why transitioning your career to software development *might* be a good move for you too.

1. **The pay**: This one is obvious. We all work to make money, and software developers make pretty good money. My very first junior developer role started at a $70,000 annual salary. While that starting pay isn't consistent for *all* junior developer roles, it's not that unusual either. And there is plenty of room for increasing your income as you gain experience. As you learn more, you become more valuable. After 4+ years in the field, my annual salary is already in the 6-figures.
2. **Room for career growth**: This one goes alongside pay, but as you gain more experience as a software developer, you will have opportunities to advance in your career. These opportunities include becoming a senior software engineer, a manager, or other higher administrative roles.
3. **In-demand job**: There are tons of companies looking for quality software developers. I won't lie: getting your foot in the door at that first job can be very difficult. But getting future software development jobs is not difficult once you're in and have proven yourself valuable.
4. **It's fun**: I think coding is fun. It's like solving little logic puzzles. And all the while, you are building something awesome.
5. **It's rewarding**: You get to build excellent applications that real people use. You feel great pride when you push out that finished product and see people using it.

## Am I smart enough to code?

The short answer is, **yes, you are**. Before I learned to code, I thought coding was magic. Super smart people wrote complex, arcane words, and my computer does fantastic things. I thought you had to go to school for years and years of intensive struggle to learn these secrets. And even then, only geniuses could understand it. **Wrong!** You do not have to be a genius to learn to code. You do not even have to have above-average intelligence. You do not even need to be good at math.

Ultimately, coding can be super simple. If you have a complicated problem, you break it down into smaller problems. For example, to do large task `A`, you solve smaller tasks `B`, `C`, and `D`. And all these smaller problems come down to simple logical statements directing a computer to do things. "computer: print 'hello world", "computer: make this word green", "computer: add these two numbers together".

Yes, at first, you *will* feel out of your depth. I certainly did when I started. Everyone does at first. There is a lot to learn. But learning to code is like learning to dance, play an instrument, or any other skill. You get started by learning the basics. And believe me, you can learn those basics. And once you are comfortable with those, you start learning a little more complicated stuff. But it's not so bad now because you already know those basics. And those skills keep building until you eventually solve those significant, complex problems. But they don't seem so hard anymore. And stuff that used to seem impossibly complicated is now simple. You'll learn it in small, easy-to-understand, digestible chunks. And as concepts layer on top of each other, and as you practice what you learn, things get easier.

## Disclaimer

**I am not selling anything with this blog post.** You'll find no advertisements on this website. Throughout the article, I list some resources (platforms, courses, books, podcasts). I am not sponsored by or associated with any of these products. I just think that they are quality resources that I have used. I am writing this blog post simply because it is the article that would have helped me out when I started my coding journey. The ideas here are not very original -- just repackaged and concentrated in one place from many sources (some of which I list at the end), including my personal experience and conversations with other developers.

## How to use this blog article

When I started writing this blog article, it was just going to be a list of resources I used in my self-education journey to land my first job as a software developer. But it ended up blowing up into a full-on guide for *anyone* to go from knowing nothing about coding to landing their first job as a junior software developer, and it became a lot more detailed in the process. So it is quite *long*, and many of the details won't make sense until you *start* your software development journey. But they still might be helpful to hear as a primer.

So yes, reading the blog article top-to-bottom is okay, and you will get a lot of good stuff out of it. But some of it won't be very meaningful early on, so maybe bookmark it and come back later at different stages of your learning-to-code journey, as some terms and concepts make more sense in your learning context. ü§∑‚Äç‚ôÇÔ∏è Sound good? Let's dive in!

## The three main paths to becoming a software developer

Before we talk about how I learned to code, let's talk about the options *anyone* has to learn to code. If you are looking to transition into software development, there are three main paths to achieve this goal. You could (1) **get a college computer science (CS) degree**, (2) **train with a coding Bootcamp**, or (3) **self-educate**. All three routes have strong advantages and disadvantages. The best path for one person might not be the best path for someone else. We'll briefly go over some of those advantages and disadvantages. My sources for these paths include the [*Command Line Heros*](https://www.redhat.com/en/command-line-heroes){: target="_blank", rel="noopener noreferrer" } podcast episode, ["Becoming a Coder"](https://www.redhat.com/en/command-line-heroes/season-5/becoming-a-coder){: target="_blank", rel="noopener noreferrer" }, the book [*The Complete Software Developer's Career Guide*](https://simpleprogrammer.com/products/careerguide/){: target="_blank", rel="noopener noreferrer" } by John Sonmez, the [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#learning-to-code-learn-code){: target="_blank", rel="noopener noreferrer" }, [bestcolleges.com](https://www.bestcolleges.com/bootcamps/payment/bootcamp-cost/#comparison){: target="_blank", rel="noopener noreferrer" }, [thinkimpact.com](https://www.thinkimpact.com/average-college-tuition/){: target="_blank", rel="noopener noreferrer" }, and conversations I've had with other software developers and my own experiences. After this section, for the remainder of the article, we'll hone in on the route I took, **self-educating**. If that's all you're interested in, feel free to skip to the next section, where I talk about *how* I went about self-educating.

### College computer science (CS) degree

This is the big one. The most recent [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#learning-to-code-learn-code){: target="_blank", rel="noopener noreferrer" } found that ~62% of developers learned to code through a college or university. Formal training with a computer science or similar degree is a *very* popular route. And for a good reason. Individuals who earn a CS degree gain a deep understanding of computer theory as well as a deep understanding of code fundamentals. They get a guided program with lots of resources for help. And they get that shiny diploma that employers love, along with networking opportunities like career fairs and internship programs. The downside? It can be costly, both in terms of money and time.

Who is the college CS degree path a good fit for? This path *can* be a good fit for anyone who feels confident about going into software development and has the time and resources to go to school (or back to school). I think it is a perfect fit for individuals with no previous college degree since having any college degree can give individuals an advantage over those without one when seeking that first job. It's also a good fit if you want to deeply understand computer theory and fundamentals. However, it might not be a good fit if you don't have the time and money to invest four years of your life with limited to no income.

Advantages:

- **depth and quality**: A CS degree will give the greatest depth of understanding of how computers work "under the hood". Because of this, someone with a CS degree will likely have a deeper understanding of theoretical and fundamental topics like complex data structures and algorithms. Of course, many employers understand that this doesn't *always* translate to the skill of writing high-quality production code in a real-world job. But in some cases, it might, and it certainly doesn't hurt.
- **guidance**: The plan is laid out before you. You know what classes you need to take to achieve the degree. You have an instructor guiding you through the topics. You have TAs and other students to go to for help when you get stuck.
- **employability**: Some employers just want that CS degree. Certain employers won't even consider candidates without a CS degree, especially without other programming experience at a real job. Having the degree makes getting your foot in the door at a quality company much more straightforward.
- **networking**: Many universities offer programs to assist their students in getting into a career. This assistance might be in the form of career fairs, internship opportunities, or clubs or forums where students have chances to meet with employers.

Disadvantages:

- **cost**: A university education might cost anywhere from $40K to well over $100K over four years, depending on the University and financial aid. Software developer jobs are notoriously lucrative, so you'll be able to pay this back in short order, but as with any degree, there's the risk of dropping out without getting the degree and still having that bill.
- **time**: An average bachelor's degree takes four years as a full-time student. That's a long time. Furthermore, you **aren't working** (at least full-time) during those four years, so you are missing out on income during that time.

### Coding bootcamp

That same [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#learning-to-code-learn-code){: target="_blank", rel="noopener noreferrer" } found just over 10% of individuals learned to code through a coding boot camp, but that number seems to be on an upward trend. What is a coding Bootcamp? It's an intensive program that lasts anywhere from 4 weeks to several months, where they take individuals with potentially no coding experience and teach them everything they know to be a proficient coder in real-world coding jobs. Many specialize in one coding language. They are generally much cheaper than the CS degree route and offer many of the same benefits, like set course schedules with guided classes and lots of help. They also usually help with job networking and placement, so many have very high employment rates after graduation. However, because of their growing popularity and lack of regulations for their programs, a subset of such coding bootcamps are low quality and have poor job placement rates. You'll want to thoroughly research all your bootcamp options before picking the one that's right for you.

Who is the coding Bootcamp path a good fit for? Overall, I think training at a coding Bootcamp is an excellent option for *any* person wanting to transition their career into coding. It might be a good fit for you if you want to make that transition *quickly*, if you wish to help and accountability along the way to make sure you stick to your learning, and if you want extra help with networking to get that first job.

Advantages:

- **time**: This is probably the fastest option to go from no coding experience to landing a coding job. Coding bootcamps can range in time from a month to several months.
- **full or part-time**: While not as flexible as self-educating, different coding bootcamps have different time requirements. Most programs are full-time, immersive programs. However, some programs are part-time, in the evenings, so you could work your day job and learn to code nights and weekends.
- **cost**: Coding bootcamps are generally cheaper than universities. A several-month Bootcamp will typically cost $10,000-$20,000. On top of that, some coding bootcamps won't charge anything until you land your first coding job. In addition, some offer no money down plans and a money-back guarantee if you don't find a job.
- **guidance**: As with the CS degree, you have a set curriculum and a schedule. You have an instructor guiding you through the topics. You have teachers, TAs, and other students to go to for help when you get stuck.
- **employability**: Some employers are sticklers for that 4-year college CS degree. But *many* employers have come around to the idea of coding bootcamps and will rank them on par with a quality CS degree when hiring new developers.
- **networking**: Coding bootcamps want you to get a job after graduating. Most will facilitate employment networking opportunities and help you land that first job.

Disadvantages:

- **cost**: I put this one in the advantage *and* disadvantage category. While I think coding bootcamps are reasonably priced, they can't touch the low cost of self-educating. And in some cases, you might have to foot a hefty bill even if you *don't* land a job.
- **Inconsistent quality**: There are a lot of coding bootcamps out there that are **excellent**. üéâ But there are no regulations around coding bootcamps, and some coding bootcamps are not very good or are even predatory. So do thorough research on any Bootcamp before you sign that fine print.

### Self-education

The [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#learning-to-code-learn-code){: target="_blank", rel="noopener noreferrer" } was a little confusing to determine who self-educated without the help of a CS degree or a bootcamp. Still, if we assume that the three categories don't significantly overlap, approximately 27% of developers learned via self-education. So what does it mean to be self-educated? The term is a little misleading. You're learning from *someone*. But generally, that learning comes from pre-recorded material outside a program's broader context. It means learning from sources like one-off online courses, books, blogs, podcasts, videos, games, challenges, documentation, other people's code, etc. There is no curriculum set for you, no teacher or TA to ask for help from, and no set of assignments. Because no one provides these things for you, if you choose this route, you'll need to get those things yourself. You'll need to design *your own* curriculum, set *your own* schedule and learning pace, *find* a network of people you can ask for help from (or muddy through yourself), and assign *yourself* topics to learn and projects to build.

Who is this path good for? For one, it might be a good starting path for *anyone*. Because this path is free (or very cheap by comparison), it is very low risk. Anyone thinking about coding might at least *start* on the **self-education** path and see what it is all about. You can always *transition* to a college CS degree or bootcamp and be no worse off than when you started. It might also be a good fit for you if you need to keep a full-time job and want to learn coding on the side at times that fit *your* schedule and that match *your* learning pace. While learning on your own schedule at your own pace can be one of the most significant *advantages* of self-educating for some, it can be a huge *disadvantage* for others. It means (1) you have to figure out a curriculum and schedule to get from where you are to where you want to be (not easy when you don't yet know what it is you need to learn), and (2) you have to keep *yourself* accountable to stick that curriculum and schedule. With no one holding you accountable, you might struggle to find the motivation to stay on course. That is to say, **self-educating** might not be the best fit for you if you need extra help finding your learning path and staying accountable. It also might not be the best fit for you if you find yourself needing lots of extra help from an authority figure or if you don't like going it alone.

Advantages:

- **cost**: This is the cheapest option by far. Depending on the resources you opt to use, expenses can range from 100% *free* to a few hundred dollars. Because costs are so low, this option is also very low risk. There's virtually no financial fallout starting this path and then, later on, deciding coding isn't for you.
- **flexibility**: Learn on your own schedule and at your own pace. This flexibility is a massive advantage if you can't afford to quit your job to go to school or attend a coding bootcamp.

Disadvantages:

- **lack of networking**: There's no institution networking with companies on your behalf. You'll have to put in extra work to do the networking yourself.
- **lack of guidance**: There's no one to tell you what to do and ensure you're doing it right. You'll need to set your own curriculum, check your own work, and seek out your own network of people to help you.
- **lack of accountability**: There's no one making you do your work. If you aren't feeling motivated, you won't do the work you need to do to get to where you want to go.
- **more to prove**: *Some* employers will be skeptical of the quality of self-educated individuals, especially for that first-time job. Some won't even consider an individual who doesn't have a CS degree or Bootcamp certificate. However, increasingly, more and more employers are becoming open to hiring individuals with no formal training as long as they can prove they know their stuff. Some even think it shows tenacity not to need any hand-holding to get to this level. Either way, you'll have to work harder to prove to that first employer that you're a good fit.

### Education path conclusions

Those are the three main paths you can take to take yourself from no coding experience to landing your first coding job. All paths are viable, and there is no one *best* path. You'll have to decide what sounds best *for you*. Each path has advantages and disadvantages, and you should do more research beyond this article before picking any one path. *I* chose the **self-education** path. It worked out well for me, but it was not easy. There was a lot of difficulty and uncertainty along the way. That **self-education** path is the path we'll be talking about for the rest of this article. But even if you chose another path, I think some topics we'll discuss might be excellent supplements to your coding education journey. And as I mentioned above. You can always *start* down the **self-education** path and then transition to another path later.

## Choosing a language

When it comes to coding, everyone has their favorite language. That makes sense. The language is the thing you use to *express* what it is you want the computer to do. And it's the thing you're working with for hours on end. You want to like it. And there are a *lot* of languages to choose from. So without knowing anything about them, how are you supposed to choose one that is right for *you*?

### Think about language popularity

Okay, just pick a language. But what even are my choices? I recommend picking one of the more popular languages. The more popular a language is, the more likely it is to have a big community to support you (think more courses, tutorials, and people to talk to). These are the top 10 most popular languages according to the [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#most-popular-technologies-language){: target="_blank", rel="noopener noreferrer" }. I pruned the actual list, removing languages that are more helper languages than full-fledged programming languages. The percentage attached is the percentage of respondents who use that language (out of over 70,000 respondents). Any language on this list would be a great choice for a first programming language in terms of popularity. Even if a language you're interested in *isn't* on this list, it still probably has a great community and would be a good pick for a first language.

1. JavaScript (65%)
2. Python (48%)
3. Java (33%)
4. C# (28%)
5. C++ (23%)
6. PHP (20%)
7. C (19%)
8. Go (11%)
9. Rust (9%)
10. Kotlin (9%)

### Consider how easy it is to learn

One thing you might consider when picking a language is how easy that language is to learn. All languages aren't that bad once you get to know them. But some just seem to be easier out the gate. Maybe their syntax is more straightforward, their coding style is simpler, or they do more for you, so you have less to think about. What makes a coding language "easy" and which languages are easy to learn vs. which languages are hard to learn is *very* subjective. Here's a list from [codingdogo.com](https://www.codingdojo.com/blog/easiest-programming-language-to-learn){: target="_blank", rel="noopener noreferrer" } for their picks of the top 5 easiest and top 5 hardest languages to learn. While I have only used a few of the languages on this list, I think these choices are reasonable from my limited experience and from talking to other developers. For *why* the site thinks these are easier and more difficult languages, you'll have to [read their article](https://www.codingdojo.com/blog/easiest-programming-language-to-learn){: target="_blank", rel="noopener noreferrer" }.

Top 5 easiest to learn

1. Python
2. C
3. Ruby
4. Java
5. JavaScript

Top 5 hardest to learn

1. C++
2. Prolog
3. LISP
4. Haskell
5. Malbolge

### Consider language use case

If you have an idea of what *type* of programming you want to do, you might pick a language that is well suited for that job. Specific languages tend to be better suited for particular programming needs. Here's a list of some common programming needs and languages that are well suited for them. This is another subjective topic. Some people might consider other languages better for these jobs than the ones I chose. If that's you, or if your favorite language for a job isn't on my list, don't hate. üòõ I'm sure that's a fantastic choice too.

**Front-end web development (code running in your browser):**

- **JavaScript**: This is the only language in town for this job alongside its spinoffs like **typescript** and its helper languages **HTML** and **CSS**.

**Back-end web development (code running on a website server):**

- **Node.js**: This language is the same as **javascript** with some subtle differences that allow it to run on a server. This similarity is nice because you can learn just one language for both front-end and back-end web development (i.e., full-stack web development).
- **Python**: Python is an excellent choice for web development because it offers a host of clean, easy-to-use web frameworks. I'm biased because this is *my* language of choice.
- **PHP**: PHP is a veteran of the back-end web space with many web frameworks and a large community.
- **C#**: The Microsoft programming language has a great community and remarkable, opinionated back-end frameworks.

**Data Science:**

- **Python**: Python is the most popular data-science choice nowadays. It has excellent frameworks for efficiently processing large datasets and for data visualization. It is efficient for these purposes because the core of the calculation processes is written in **C** under the hood. It is the only choice when using certain machine learning frameworks.
- **R**: A language whose primary purpose *is* data science. It is older in the data science community and quite popular.

**Android development:**

- **Kotlin**: Google switched to Kotlin as the official language for Android app programming in 2017. It's simpler than Java, with extensive libraries for Android development.
- **Java**: The original official Android app programming language. It is an extremely established language with a vast community.

**iOS development:**

- **Swift**: Apple launched Swift in 2014 specifically for iOS development, which has been growing in popularity.
- **Objective-C**: The original iOS language. It is still widely used, especially in older, established applications.

**Video game development:**

- **C++**: A very *fast* language, famous for creating game engines and games themselves.
- **C#**: A higher-level language popular in video game scripting.
- **JavaScript**: Very popular in creating games hosted on web browsers and mobile platforms.
- **Java**: A universal language popular in various games, including Minecraft.

**Embedded systems and IoT:**

- **C++**: It is a relatively low-level language with good library support that makes it a popular language for embedded systems, and it is *fast* when written well.
- **C**: A low-level language that is *fast* and is the language beneath the hood for many other higher-level languages like **Python**. Many embedded systems are written directly in **C**.
- **Python**: with the advent of sub-languages like **micropython** that make Python smaller and fit well with embedded systems, Python has growing popularity in the embedded systems space, mainly because it is often considered an easier language to work with than **C++** or **C**.

### Just pick one and stick with it for a while

Here's the biggest secret when it comes to picking your first language. **It doesn't matter all that much which language you choose first.** All the languages (at least the more popular ones) are pretty good. And in the end, they all do pretty similar things. For the most part, they all have the same components: **grammar**, **types**, **variables**, **loops**, **conditional statements**, **functions** (if you don't know any of those terms, don't worry about it, there's plenty of time to learn üòâ). Of course, there are some differences in language components and structure (for example, object-oriented languages vs. functional languages). But mostly, the differences come down to grammar subtleties and external helper libraries available to the language. For the most part, **once you learn one language, it becomes straightforward to learn a second language**, and it is easier still to learn a third language.

So don't stress too hard about that first language choice. The most important thing you are learning when first learning to code is how to use all languages' underlying components (the **variables**, **loops**, etc.). I recommend sticking to that first language until you feel comfortable writing in it. At least finish a course and create a project with it. Switching away from that first language too early will distract you from learning those core concepts common to all programming languages that are important things to learn.

### Language choice conclusions

To conclude, **any** of the above-listed languages would make an excellent choice as a first programming language. There are plenty of job opportunities for any of the above-listed languages, especially as remote work becomes more popular. So consider the language's popularity and your use case. But in the end, the choice doesn't matter as much as you think. Just pick one and stick to it so you can learn the underlying tools common to all programming languages. Once you understand the fundamentals common to all programming languages, it'll be easy enough to switch languages later on.

I picked Python. It is very popular and pretty to look at with a simple-to-learn style. It can handle complex projects, has a wide range of jobs it's good at, and has a great community. But you might choose JavaScript because you want to learn how to make awesome front-end web applications, or you might select Swift because you are interested in creating iPhone apps. So just do a little research and pick one. And whatever you choose, don't stress. They're all excellent, and you can always change your mind later.

## Getting started

Okay, you've decided you will start your coding **self-education** journey, and you've picked a programming language. Where do we go from there? The options are overwhelming. How do you even get started? My best advice here is **just do *something***.

It is *really* hard to know what learning path is right for you when you are first starting. So I recommend just code *something* to begin learning what is suitable for you. The more you code, the more you'll know what works for you. You're never going to have a perfect lesson plan out the gate. Promise yourself right now, "I'm going to spend an hour coding on 'X' platform." It doesn't really matter what resource you are using to code. The hardest part is breaking that deadlock in your mind and deciding you're going to code *something*. Code for an hour. At the end of that hour, re-evaluate. Maybe you choose to keep doing what you were doing -- the course you are taking or the coding game you are playing is exciting, and you want to keep exploring it. Then check in after another hour. Maybe you decide to take a break today, but tomorrow, for your next coding hour, you have something new to research based on what you learned coding during that hour. It's cheesy but true: "A journey of a thousand miles begins with a single step." Take that first step, and every step after that will be easier.

Start doing *something*? Teddy, that's pretty vague. Do you have any more specific suggestions? Sure. Here are a few resources that would be an excellent get-your-toes-wet introduction to coding.

- [Codecademy](https://www.codecademy.com/learn){: target="_blank", rel="noopener noreferrer" }: This is a cool website that offers coding classes in the browser. You can take interactive courses in languages like **Python**, **JavaScript**, **Java**, and various others. Create a free account, pick a language, and start taking that introductory class.
- [FreeCodeCamp](https://www.freecodecamp.org/learn){: target="_blank", rel="noopener noreferrer" }: This is another similar fantastic website that offers a variety of free interactive courses you can take directly on their website.
- [Code Combat](https://codecombat.com/){: target="_blank", rel="noopener noreferrer" }: Video games more your speed? This is an awesome website where you learn to code while playing a dungeon crawler video game. Type code commands to move your hero through dangerous dungeons and slay your foes.
- [General Assembly course](https://dash.generalassemb.ly/){: target="_blank", rel="noopener noreferrer" }: General Assembly is a company that offers classes, many of which are live, most of which cost money. However, they have an excellent introduction to web development course that is on-demand and free.

Those are just a few resources I've tried and think are perfect for getting your feet wet with programming. And you don't have to finish any of them to get value. Starting an interactive course or game will get you on that path to learning and get you excited to learn more! In addition, it'll give you more information about what steps you need to take along your coding journey.

## Make yourself a learning game plan

You did it! You coded *something*! üéâ Congratulations! Even if it was an hour (even 15 minutes), taking an interactive class, or playing a coding video game, getting started coding *something* is one of the most challenging and critical mental hurdles to get through, and you should be proud of it. So pat yourself on the back. Feel free to linger on that step. Finish that course or coding video game if you like. It's worth it. Once ready, let's start making a learning game plan (or a learning curriculum) for the long journey ahead. Our end goal? Become a proficient coder and get hired as a junior developer.

That curriculum is going to look different for everyone. It will depend on what area you want to go into (web development, smartphone app development, data science, etc.). It will depend on your chosen coding language (Python, JavaScript, C#, etc.). It will depend on your learning style (do you prefer online courses, reading books, etc.) -- I recommend trying a combination of styles. And it will depend on what pace you feel comfortable with (some topics might be easy, others might require lingering on until you understand them).

Below I'll list some considerations you should consider as you design a game plan.

### Keep it fluid

At first, try writing a broad outline of the step you need to take to get from where you are now to where you want to be (presumably hired as a junior developer). Write these high-level goals in a google doc or spreadsheet. When writing your learning gamelan, you aren't going to know what you don't know, especially at first. Make the plan **specific** for goals you want to accomplish soon and **vague** for goals you want to achieve in the distant future. Then as you move forward, fill in the details. As you learn more, keep updating the plan. As you learn new concepts, check back on your game plan and update it to fit your new mental model.

### Have achievable, measurable goals and timelines

Try to be as specific as possible when writing your goals, especially those you want to achieve soon. Each goal should be achievable and measurable. For example, "Complete 'X' Udemy course", "Finish reading 'Y' book", or "Finish 'Z' project and present it to my family". Then attach timelines to those goals. For example, "Complete 'X' Udemy course -- 1 week", "Finish reading 'Y' book -- 2 weeks, "Finish 'Z' project and present it to my family -- 4 weeks. If it works better for you, you can assign dates instead of time periods -- for example, "Complete 'X' Udemy course by October 1st. By setting achievable, measurable goals, you're setting yourself up for success in making progress on those goals. Likewise, by setting feasible timelines for your goals, you're helping to motivate yourself to get those goals done promptly.

### Break down bigger goals into smaller goals in your schedule

Either in the same "Game plan" document or a daily schedule, break down your goals into weekly and daily goals. For example, from our goal "Complete 'X' Udemy course", our weekly goal would probably still be "Complete 'X' Udemy course," and we might break down a daily goal for Monday of "Complete sections 'A' and 'B' of 'X' Udemy course". For the goal "Finish reading 'Y' book -- 2 weeks", we might break down to a weekly goal of "Finish chapters 1-12 of book Y" and further break down Tuesday's daily goal to "read chapters 1-3 of book 'Y'". For the goal "Finish 'Z' project and present it to my family -- 4 weeks", we might break that down to a weekly goal of "write the logic for moving and battling". We might further break down our daily goal for Thursday: "Write the game logic for making the enemies chase our hero" (that one got more specific than the other examples üòÜ). Try to check off these daily goals every day. Then at the end of each week, examine how you did this week. Were you good about accomplishing your weekly and daily goals? Are you on track for your big-picture goals? It's okay if you're not but adjust accordingly.

### An example curriculum (what I did)

This example curriculum (or learning game plan) mirrors what I did while learning to code. I made some changes to make the plan fit more closely with what I would have done in retrospect, knowing what I know now. I also made up the timeline -- I don't remember the exact dates. In the [self-education resources](#self-education-resources) section, I discuss the specific resources used in this plan. Some of these timelines might overlap.

> - free - Take course [CS50X from Edx](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x){: target="_blank", rel="noopener noreferrer" } to get CS50 fundamentals down. - 12 weeks
> - free - [while taking CS50X] Start listening to programming podcasts in spare time (during commutes, while doing chores or exercising, etc.) - forever
> - ~$25 - Take Udemy course [Learn Python Programming Masterclass](https://www.udemy.com/course/python-the-complete-python-developer-course/){: target="_blank", rel="noopener noreferrer" } to learn Python in detail - 4 weeks
> - ~$10 - [while learning python] Read the book [*The Complete Software Developer's Career Guide*](https://simpleprogrammer.com/products/careerguide/){: target="_blank", rel="noopener noreferrer" } by John Sonmez to learn more about becoming a developer. - 4 weeks
> - free - [while learning python] [Start attending monthly python coding meetup group meetings](https://www.meetup.com/){: target="_blank", rel="noopener noreferrer" }. - 1x every month
> - free - Learn [pygame by YouTube with Sentdex tutorial](https://www.youtube.com/playlist?list=PLQVvvaa0QuDdLkP8MrOXLe_rKuf6r80KO){: target="_blank", rel="noopener noreferrer" } to learn how to make a python video game. - 1 week
> - free - Write first capstone project, a video game in PyGame with Python. This project helps improve those Python fundamentals. - 4 weeks
> - ~$24 - [while writing first capstone project] Read [*Effective python*](https://effectivepython.com/){: target="_blank", rel="noopener noreferrer" } by Brett Slatkin to hammer down python skills and pythonic thinking - 4 weeks
> - free - Start writing a coding blog, first article = "how I wrote a game in Pygame with Python" - 2 weeks (\*I did not start a blog until later in my career but wish I had started one about here)
> - free - start doing coding challenges at [HackerRank](https://www.hackerrank.com/){: target="_blank", rel="noopener noreferrer" } in spare time  - forever
> - ~$18 - Take Udemy course [Python for Data Science and Machine Learning Bootcamp](https://www.udemy.com/course/python-for-data-science-and-machine-learning-bootcamp){: target="_blank", rel="noopener noreferrer" } to learn data science techniques with python - 2 weeks
> - free - Find a project at work to use Python and data science (I found an opportunity to use my coding to write an application that compared DNA sequences in Excel sheets for the lab I was working in) - 2 weeks
> - ~$18 - Take Udemy course [Python and Django Full Stack Web Developer Bootcamp](https://www.udemy.com/course/python-and-django-full-stack-web-developer-bootcamp/){: target="_blank", rel="noopener noreferrer" } to learn Python web development with the Django web framework. - 2 weeks
> - free - Write a capstone project -- a stock trading and personal finance application. This project improves web development skills - 4 weeks
> - ~$29 - [while taking Django Udemy course and writing 2nd capstone project] Read the book [*Python Testing with pytest: Simple, Rapid, Effective, and Scalable*](https://pragprog.com/titles/bopytest2/python-testing-with-pytest-second-edition/){: target="_blank", rel="noopener noreferrer" } by Brian Okken to learn how to do automated testing with Python and pytest - 4 weeks
> - free - write another blog article, "How to write a Django web app" - 2 weeks
> - free - Write portfolio web app in Django - Use the skills we learned with Django to write an awesome portfolio web app to show potential employers. Include in it our two capstone projects and maybe a couple of smaller projects we made while learning various programming skills. - 4 weeks
> - free - [while writing portfolio web app] Start writing resume and LinkedIn portfolio
> - free - Bump up career networking. Tell everyone about the awesome stuff I've been learning and my projects and how I'm looking for a job - forever
> - free - [while networking] Practice interviewing
> - free - [while networking] Apply for programming jobs in the python space, a couple of jobs every day

This example learning game plan might take approximately nine months to execute, leaving another three months for job applications to land a job by the end of the year. While applying for jobs, you would want to continue your learning path on whatever tools and projects interest you while continuing to aggressively career network and practice your interviewing skills.

Next, we'll talk about how to learn and accomplish the goals of your learning game plan.

## Code at least 15 minutes every day

**Try to code or learn about coding for at least 15 minutes *every day***. More is better, but at least 15 minutes a day is *so* valuable. It's not possible *every single day*; things happen. But it is possible *almost* every day. **Prioritize your commitment to code** like you would brushing your teeth or cooking dinner. You are building unstoppable learning momentum. If you are not consistently learning every day (or at least most days), with no one to hold you accountable, you can easily fall off course and lose motivation. And then it can be hard to get that learning momentum back. Stay the course, stick to your learning game plan (keeping it flexible), and you'll be amazed at how much you can learn quickly, even with a bit of progress every day.

## Learn by doing

This is very important. The best way to learn to code (and many other things in life) is by doing it yourself. **"Practice, practice, practice!"** Later on, we'll talk about some specific learning resources. The resources include courses and books. When you are using these resources **type the code out yourself, line by line**. It is possible to read an entire coding book or take a full course without writing *any* code yourself. **Don't do that!** You will learn the topics 10X better if you write the code yourself.

When an instructor is coding, do not just watch the video! **Code along with them.** Type what they are typing into your own file and run the code yourself. Pause the video and make changes to that code. See how the tweaks you make change the output. If an instructor offers coding assignments, do those. Do not just watch the solutions afterward. After completing a course, create a small project that uses what you learned in that course.

When reading a programming book, **write out the code yourself**. There might be times you are reading where you don't have access to a computer. That's okay. Later on, when you do have access to a computer, write code that uses what you learned from the book. Copy and run examples from the book. Tweak examples and see how the output changes. Create a small script or project that uses concepts taught in the book.

Writing your own code while taking a course or reading a book *will* slow down that course or book. *That is okay!* It's worth it. The upfront cost of taking the time to write out the code yourself will pay dividends in learning retention. Furthermore, creating scripts and side projects outside of the context of a course will pay off immensely in terms of your understanding of code.

## Learn these critical topics

What kinds of things should you include in your learning game plan? In the following sections, I'll talk about some things you should probably have in any game plan, regardless of language and the area of interest you want to pursue. But, first, some topics that are important for any developer.

### Hello World

The first thing you'll need to learn when learning any programming language is "Hello World". You need to know how to make the simplest code possible that outputs something. Typically, teachers will have you print the words "Hello World" to the screen. This action is your introduction to your new coding language. If you went through [getting started](#getting-started) above, you probably already wrote your "Hello world" code. Congratulations, check that one off the list! üòÉ

### Your language's core components

When learning your first language, you'll need to learn your language's core components. These are things that all programming languages have in common (give or take some minor variations). I'll list some of those core components below. Of course, you won't know any of these if you are new to programming. But they are not so difficult to learn. Luckily, if you are taking a course or reading a book meant to teach your language to beginners, that course or book should always cover these components and how to use them with your language of choice. Soon you will be an expert at wielding these core components to get a computer to do tasks for you. The core components include:

- **Variables**: These are words that store data to be used later on.
- **Data types**: These are *what* type of data is stored. They include things like numbers, words, or phrases (called strings in coding), "true" or "false" keywords (called booleans in coding), and more complex types in the form of data structures.
- **Operators**: These are things like `+`, `-`, `x`, `>`, `<` that can be used to compare and manipulate data.
- **Data structures**: These are *how* complex data is stored. These are things like ("lists" or "arrays"), "sets", ("dictionaries", "maps", or "hashes"), ("objects" or "structs"), and many others. Different data structures are optimal for solving different problems.
- **Control flow**: These are things like "if/else/then" statements and "loops" that direct the flow of logic for a program.
- **Functions**: These are ways to store chunks of code so the code can be reused without being re-written.
- **Classes**: Not all programming languages have classes. They are specific to **object-oriented** programming languages. But even if your language of choice doesn't use them, they are worth learning about.

### Object-oriented, procedural, and functional designs

There are three main designs (or styles) of coding. Specific languages require one of these coding styles. Others can use a combination of styles based on preference. I'll review them briefly, but you should dive deeper into these topics in your studies. If these explanations don't make sense now, that's okay. They will make more sense when you learn them for real on your coding journey.

- **Object-oriented**: In this coding style, all things are "objects". Objects are created by initializing a class. For example, we could have an "Animal" class. We would use this "Animal" class to initialize an "animal" (non-capitalized) object. This might look like `Tigger = Animal()`. Here, my cat `tigger` is an "object" from the `Animal` class. He might have "attributes" associated with him like `tigger.has_fur` which would be `true`. And he might have "methods" associated with him like `talk()` which might do something like print "meow" to the screen.
- **Functional**: This coding style usually has no classes or objects. Instead, data is passed from function to function to achieve a goal.
- **Procedural**: In this coding style, the code is written and run top-to-bottom without including functions or classes. This is a more primitive coding style, but it can still be useful, especially in small scripts.

### Advanced topics

Here are a few advanced topics you will probably want to learn about on your coding journey, along with brief descriptions. You might not need to understand *all* of these topics on a deep level, but you should at least understand all of them at the surface level, and you might choose to deep-dive into some of them.

- **Recursion**: These are instances where functions call themselves
- **Pointers**: These are things that "point" to the place in your computer's physical memory space where a variable or object from your code resides.
- **Memory management**: How do you handle the memory your code uses? Some languages do this for you; others make you do it yourself.
- **Asynchronous code**: This is code that does more than one thing simultaneously (sort of).
- **Cybersecurity**: How to write safe and secure code.

### Peripheral topics

It would help if you learned some peripheral topics based on your coding focus area. Here are some topics you might want to have a firm understanding of early on in your coding journey.

- **How binary works**: Learn how the binary system works and why it's so important to computer programming.
- **IP Address assignment**: Learn your computer's IP address and how it gets assigned.
- **how the internet works**: Learn what happens when you hit "send" on a web page form. Where does your data go, how does it get there, and how does it get a response back?

### Source control (or version control)

Let's say you're writing code for a website. You save the code files you wrote to your hard drive. Let's say you make some changes to those files, adding a new feature. You write your changes and then save your files again *overwriting* those old files. But shoot, the website breaks when you deploy the changes. You want to go back to the previous website version where things were working, but you can't because you overwrote those old files. So now you have to spend a lot of time trying to figure out how things worked when your website worked while your website continues to be offline. This is a problem.

One solution is to save a new file version for each change. For example, maybe we have `my_website_1,` and for the following change, you make `my_website_2`. That way, if `my_website_2` breaks the website, you can fall back to `my_website_1`. But now you are accumulating many files you need to keep track of. And let's say you give someone else the code because they also want to make changes. But their changes conflict with your changes. So now, who's `my_website` file do we use? This system becomes a mess very quickly.

Source control (also called version control) solves this problem. There are a few source control systems, but the main one used today is called **git**. How does git work? Code gets stored in a central **repository**. When someone wants to make changes, they pull that code down to their system. First, they make their changes locally, and then they push their local changes up to the central repository. The updates they pushed to the central "repository" become the version used. Git also keeps track of the history of all the changes made since the repository was created, making it easy to go back to a previous version. Also, if multiple people are working on the same code, git has mechanisms for merging two sets of code that have both made changes.

As a developer, version control will be a super important tool in your tool belt. I recommend learning the basics of using git very early in your coding journey. Git can be complicated for edge use cases, but the basics are straightforward to learn. Then store all of your code in the cloud in a git repository. The main, cloud git repository is called [GitHub](https://github.com/){: target="_blank", rel="noopener noreferrer" }. Make yourself a GitHub account and start pushing all the code you work on up to repositories associated with your GitHub account. You can choose to make those repositories public or private. The added benefit of having all your code on GitHub is that later on when you want to share your code with others (say a potential employer), you can just point them to your GitHub account to look at all your cool projects. For reference to what that looks like, [check out *my* GitHub account](https://github.com/VerdantFox){: target="_blank", rel="noopener noreferrer" } where you can see a bunch of code that I've written and stored in public GitHub repositories. [I even store these blog posts in a public repository.](https://github.com/VerdantFox/blog_posts){: target="_blank", rel="noopener noreferrer" }

### (Automated) Testing

As you write your code, you will want to test it. Manual testing is the first type of testing you will learn (out of necessity). It works like this: run your code and observe the output. Did your code do what you wanted it to do? If not, tweak it. Then repeat. Manual testing will always be an essential step in your coding process. *Automated* testing is when you write a set of instructions in the form of code called a test. That test runs your code and then checks the results *for you* to ensure the code is doing what you expect.

Why are automated tests necessary?

1. Once they are in place, automated tests reduce your workload *a lot*. There are so many things to check when running your code. For example, you will want to check how your code runs with different inputs and edge cases. If you are only testing manually, first you have to *remember* all those inputs and edge cases; then you have to input them by hand and  *then* visually observe that the results are as expected. Ultimately it is much faster to write those tests once, so you don't have to re-do that work repeatedly.
2. Your code changes in one area might have unintended consequences for other parts of your code base. The tests you wrote for one part of the code base will quickly uncover bugs from changes made elsewhere, even if you forget to test that other part of your code base manually.
3. Testable code is clean code. Automated testing will force you to write your code in a testable way. You will need to write concise, digestible code that is easier to read and maintain.

Writing automated tests is an essential skill in modern coding. It will make your code much more reliable and make changing your code later much faster because you can rely on your automated tests to catch your bugs. And you know what? I know of many projects that *don't* have automated tests. That means that by knowing this valuable skill yourself, you will have the edge over your competitors that don't have this skill when seeking a job.

### Database basics

Most programming applications have to store data. For example, they might store data about their users, their products, and many other things. The most efficient way to store and retrieve most types of data is in a database. There are two broad categories of databases you might want to know about: *relational databases* and *non-relational databases*.

#### Relational Database

Relational databases are the most popular type of database. They consist of **tables** that store data in a **tabular format**. The data is stored in **rows** and **columns**, much like an Excel or Google Sheets spreadsheet. Developers can link tables with related data to one another. For example, a `products` table could be linked to a `reviews` table if the `reviews` table has a column `product_id` with an id that matches the `id` column of a specific product (row) in the `products` table. This relationship between tables is the **relational** part of **relational databases**.

Coders can interact with these **relational databases** with a language called SQL or Structured Query Language. SQL allows coders to **query** the database to retrieve rows from those tables, add new rows, update existing rows, or delete rows. Because SQL is the primary way to interact with **relational databases**, those databases we sometimes refer to those databases as **SQL databases**. And because these databases are so popular, the ability to write SQL code is a valuable skill to pick up. You should learn the basics of how **relational databases** work and how to read and write some basic SQL code. You don't need to be an expert in SQL or relational databases to use the databases or to get hired, but it is essential to at least learn the basics.

#### Non-relational databases

Some data doesn't easily fit into rows and columns in neat tables. Developers can still store this type of data in a database, but they might store it in a **non-relational database**. Side note: because SQL is so ubiquitous when talking about databases, **non-relational databases** are also often referred to as **NoSQL databases**. With non-relational databases, instead of storing data in a **table** structure, data is stored in a **document** structure. One of the most popular **non-relational databases** out there is **MongoDB**. It stores data in **documents** that look like JavaScript objects. If that sounds like gibberish to you right now, that's okay. Developers can query the documents with a language specific to MongoDB. Another fun fact: this website stores its data in a MongoDB database, including the blog post you are reading now. üòâ

Because **non-relational** databases are much less popular than **relational databases**, I rank learning them as nice but unnecessary. So, look into **non-relational databases** if it is a topic that interests you in your coding journey. Otherwise, keep in mind that they exist and move on.

### A framework or tech stack

Every language has a set of tools bundled up nicely to make a specific job easier and more efficient. These efficiency tool bundles are called frameworks (or sometimes libraries). A tech stack is a series of frameworks working together to make a problem easier to solve. Let's take an example from web development. Both the front-end code (the code running in the users' browser) and the back-end code (the code running on the web server) probably use frameworks.

The front-end code is probably written in JavaScript. That JavaScript code might use the [react](https://reactjs.org/){: target="_blank", rel="noopener noreferrer" } **framework**, which has high-level tools for creating and keeping track of front-end components and the state of a web page, so you don't have to write those complicated low-level bits yourself. The back-end code might be written in Python. It might use the [django](https://www.djangoproject.com/){: target="_blank", rel="noopener noreferrer" } web **framework** that provides tools for accepting web requests, routing the requests to the relevant back-end code, and returning appropriate responses. And the website might store its data in a [Postgres](https://www.postgresql.org/){: target="_blank", rel="noopener noreferrer" } relational database. The react front-end framework, the Django back-end framework, and the Postgres database could be collectively considered the website's **tech stack**.

It is a good idea to pick up a framework for your language of choice and learn it well. Picking a framework is similar to choosing a coding language: you'll want to keep in mind the framework's popularity and what it is suitable for. But also, like picking a programming language, selecting the "right" framework is not as important as you think. Most popular frameworks have a great community, documentation, and job opportunities. And once you understand one framework well, it becomes easy to pick up another one.

So pick all the frameworks and tools you need to make up your "tech stack" and learn each framework and tool in the tech stack thoroughly. Use that tech stack to make a large ["capstone project"](#build-a-capstone-project){: target="_blank", rel="noopener noreferrer" } (more on capstone projects later). This learning and the associated project will be key in your quest to get hired.

### Packaging and deploying to production

When you are learning and writing code for a significant skill focus area like web development, android/iOS development, or game development, you will write that code in a development environment. You'll have your code files showing. You'll have your language and helper dependencies installed on your machine. You'll probably type a command in your terminal to run your code *on your device*. But now you need to give that code or product to someone else. You won't want to tell your product users to "install python, install these dependency packages, then open a terminal and type `run my_app.py`." Instead, you will want to give them a finished product. For a game, that might mean giving them an executable file so that all they have to do is double-click that file, and your game starts up. For a website, that will mean hosting your website on a server so they can reach it by typing in your website's URL.

You will need to learn *how* to package up your code and deploy that code to an environment for your users to consume. This is an important skill to learn and one that potential employers will surely ask you about.

### Collaboration methodologies

Since you chose the **self-education** learning path, you might be mostly going it alone. But once you get hired on at a job, you will work as a team. By learning about some collaboration methodologies, you'll give yourself a head start and sound more knowledgeable to your employers. I'm going to list the most important ones below. Somewhere along your learning journey, google these methodologies and read some Wikipedia articles about how they work.

- **waterfall**
- **agile**
- **kanban**
- **scrum**

## Self-education resources

Here are a few lists of the types of resources I think you should be using while learning to code along with some specific resources I personally used and enjoyed. Note that since I am a python developer in the web space, these resources tend to skew in that direction, but I'll try to talk about how to find resources that fit your goals as well if you aren't looking in that direction.

### Courses

Online courses will probably be one of the most important resources for you while learning to code. Check out [this blog post that suggests some of the best websites for learning to code](https://mikkegoes.com/best-websites-to-learn-coding/) with reasons why the author likes each of them. I tend to agree with these choices. While learning, I took courses from a variety of websites including [Udemy](https://www.udemy.com/), [Edx](https://www.edx.org/), [freeCodeCamp](https://www.freecodecamp.org/), and [Codecademy](https://www.codecademy.com/learn), but there are a bunch of great websites out there with awesome courses to offer. You can find a course for any skill you want to learn. Courses vary wildly in time commitments and in quality. When selecting a course, the most important things I look at are "is the course highly rated" and "is it popular"? If the answer to both of those questions is "Yes!" then it's probably a good course.

Here are a couple courses I took and why I liked them. Except for the first one, they tend to focus on my education path of python and web development. You'll notice I have a preference for the Udemy learning platform. Mostly that's because it's what I found and got comfortable with since it worked well for me. Feel free to try a few different platforms to find what works for you.

- [**CS50X from Edx**](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x){: target="_blank", rel="noopener noreferrer" }: this course is Harvard University's "Introduction to Computer Science" course available for free on the platform Edx. It has been taught by professor David J. Malan for something like 15 years now. He does an amazing job teaching fundamental computer science topics in a way that is exciting and easy to understand. There are weekly homework assignments that are *very hard* for introductory programmers, but they are all graded by automatic tests and real reviewers. The homework assignments make the learning stick. And there is a great, robust [online community for the class on Facebook](https://www.facebook.com/groups/cs50).
- [**Learn Python Programming Masterclass**](https://www.udemy.com/course/python-the-complete-python-developer-course/){: target="_blank", rel="noopener noreferrer" }: This was an example of a great course, offered by Udemy. The instructor taught Python programming for absolute beginners in a super detailed, methodical, yet fun manner with lots of examples and assignments to work on. I've taken a couple other intro classes for "X" programming language on Udemy. I've really enjoyed all of them. Just make sure to actually write the code out yourself and do the suggested assignments because there's no graded assignments in a Udemy class.
- [**Python for Data Science and Machine Learning Bootcamp**](https://www.udemy.com/course/python-for-data-science-and-machine-learning-bootcamp){: target="_blank", rel="noopener noreferrer" }: This was an awesome Udemy course for learning data science.
- [**Python and Django Full Stack Web Developer Bootcamp**](https://www.udemy.com/course/python-and-django-full-stack-web-developer-bootcamp/){: target="_blank", rel="noopener noreferrer" }: This was a great course for learning python web development in the framework I was interested in. It was taught by the same instructor as the Data Science class above. Sometimes if you find a professor you like, you can take multiple courses from them. Popular instructors tend to teach a lot of different courses. He also taught a [Flask web framework course](https://www.udemy.com/course/python-and-flask-bootcamp-create-websites-using-flask){: target="_blank", rel="noopener noreferrer" } that I enjoyed.
- **These [JavaScript](https://www.udemy.com/course/the-complete-javascript-course), [HTML, and CSS](https://www.udemy.com/course/design-and-develop-a-killer-website-with-html5-and-css3) courses on Udemy**: They were by the same author who was great at explaining concepts for complete beginners and offered great examples and coding challenges.

### Books

If reading is an effective way to learn for you, you should always be reading a code-teaching book. I tend to find good code teaching books two ways: through recommendations and through reading reviews on blogs and from Amazon. Here are a few books I read while learning to code (and since being hired) that might be good for you. Again, these books have a slant toward my language of choice -- python. You'll have to go searching for the books that work for you.

- **[*The Complete Software Developer's Career Guide*](https://simpleprogrammer.com/products/careerguide/){: target="_blank", rel="noopener noreferrer" } by John Sonmez**: This was a book I picked up early while learning to program and found quite valuable. This blog article is inspired in large part by this book. John does a great job describing what it takes to become a software developer and to self-educate to achieve that goal, and he has a lot more advice about growing your career *after* getting hired as well.
- **[*Effective python*](https://effectivepython.com/){: target="_blank", rel="noopener noreferrer" }** by Brett Slatkin: This book taught python programming concepts for writing best-practice python code. He goes into detail about some concepts and ways of thinking that I didn't get from my introductory python masterclass.
- **[*Python Testing with pytest: Simple, Rapid, Effective, and Scalable*](https://pragprog.com/titles/bopytest2/python-testing-with-pytest-second-edition/){: target="_blank", rel="noopener noreferrer" } by Brian Okken**: I wanted to learn how to get good at testing my python code. Brian does an awesome job teaching the most popular python testing framework, pytest.
- **[*Automate the Boring Stuff with Python*](https://automatetheboringstuff.com/) by Al Sweigart**: This book does a great job teaching python to beginners with a series of practical example projects.

### Code challenges

Coding challenges are great for honing your coding skills through practice with small problems. Generally problems are ranked from easy to hard. A given problem will probably take a few minutes to solve. Solutions must pass a series of automated tests to succeed. I highly recommend sprinkling coding challenges into your learning. Spend maybe 10 minutes a day (or once every few days) on coding challenges and you'll see your coding and problem solving skill improve quickly. Sites that I've tried out and liked include [HackerRank](https://www.hackerrank.com/) and [Coderbyte](https://www.coderbyte.com/).

### Podcasts

Podcasts are an awesome way to learn big-picture coding concepts and what is happening in the world of coding. I recommend listening to coding podcasts in your spare time, on your commute, when your doing chores or exercising or whenever you might listen to podcasts or audiobooks in now. Here are some coding podcasts that I listen to or have listened to in the past. There is a definite slant towards python podcasts since that's my favorite language. To find a coding podcast specific to your language of choice, try typing that language into the search bar of your podcast player app:

#### General tech/coding podcasts

- **Code Newbie**: This is a ~45 min per episode interview-style podcast where guests explain big-picture coding concepts and how they use them every day for their job.
- **Junior Developer Toolbox**: This ~45 min per episode podcast stopped airing in 2019, but its worth listening to older episodes. The premise is a few junior developers talk about their experience in their new roles and what it took to get there.
- **Command Line Heros**: This ~30 min per episode podcast mostly gives a history of computers and technology. How Windows, Mac and Linux operating systems arose, the history of various programming languages, etc. It has a really high production value, and I especially enjoyed the OS wars episodes. You might not learn much about coding, but knowing the history can be helpful for context.
- **Compiler**: This ~30 min per episode podcast, by RedHat, the same company that made the "Command Line Heros" podcast asks and tries to answer interesting questions about the tech industry.
- **IRL**: This ~30 min per episode podcast by Mozilla (the company behind the Firefox browser) talks about how tech affects us in the real world

#### Language specific coding podcasts

- **Python Bytes**: This ~30 min per episode python podcast offers the top 5 or so news items related to python each week. It's fun and digestible, possibly my favorite coding podcast.
- **Talk Python to Me**: This ~60 min per episode interview-style python podcast talks through some python framework, feature, package or major news item with a guest each week.
- **Real Python**: This ~60 min per episode python podcast features a combination of interviews, news and just general information about the language.
- **Syntax Web Development**: This 20-60 min podcast (length varies wildly) talks about web development, mostly focused on frontend stuff with JavaScript, HTML and CSS. It's pretty fun and informative.

### YouTube Videos

There are a lot of good YouTube videos out there to learn coding from. They range from concept explanations to multi-video tutorials and everything in between. If you need to learn a concept, YouTube is not a bad place to look. One YouTuber I really like in the python coding space has a channel called [sentdex](https://www.youtube.com/c/sentdex/videos).

### Blogs

There are a ton of coding blogs out there. Like this one. üòú Many of them offer great explanations, tutorials, awesome lists, you name it. I don't really follow any specific blog for code-learning. However, when I want to learn a new subject, I'll usually type it into google and a good blog article is probably the first or second hit.

### Documentation

If you want to learn a language or framework, it's often very useful to know how to read the documentation for that subject matter. Learning how to effectively read documentation is a skill you'll want to develop. I don't necessarily recommend going to the documentation as your *introduction* to a new subject most of the time -- although some packages and frameworks have documentation that include detailed tutorials which can be a great introduction to the subject. But you're going to need to be able to look at documentation to look up things like "what methods are available to a class I want to use?" and "what do the input arguments and output returns to this function look like?".

### Other people's code

Finally, a great way to learn how to *write* good code is to *read* good code. This might start out as reading good code in a tutorial. But it might be helpful at times to look up projects on GitHub that use the package or framework you're interested in and see how other people write code with that package or framework. This way you can learn best practices that you can emulate in your *own* code.

## Learn how to debug and how to handle failure

Inevitably, the code you write is going to fail to do what you want it to do. This will happen **a lot**. Like **A LOT, A LOT**. These code failures are called "bugs". The code might just give you an error or it might run successfully, but not output what you expected. In either case, you are going to want to get good at **debugging**. This is one skill that just gets easier the more experience you have. Early on in your coding journey, you are going to run into a code bug that you cannot figure out the answer to **for hours**. This is okay, do not let the bug defeat you! (that's what the bugs want üêõüòÜ) The answer might be as simple as a missing semi-colon. And there is no better feeling in the world than finally solving that pesky bug that has been plaguing you for hours. üéâ There are things you can do to help you push through the debugging process including the following.

- **google it**: Googling is possibly the most important skill to learn well as a programmer. Often times you can solve your problem by simply typing it into google and click the first link in the results. If you have a confusing error returned to you, try copy/pasting that error into google. You might find your answer quickly.
- **rubber ducking**: Explain the code out loud to an inanimate object (such as a rubber duck). Oftentimes explaining the code out loud will lead you to find the source of the problem.
- **ask for help**: If you have a friend or mentor or study buddy you can show the problem to, great! Oftentimes, someone else coming at the problem from another perspective can figure it out quickly. If you don't have someone you can show the code to, try posting your code with an explanation of the problem to [stack overflow](https://stackoverflow.com/){: target="_blank", rel="noopener noreferrer" }. Perhaps a stranger can help.
- **write print statements**: One helpful tool when debugging is to add print or log statements near where the error occurred. You might print out nearby variables to see if they contain the values you expect them to.
- **use a debugger**: Learning to use a "debugger" to can be very helpful in solving tricky bugs. It is a tool that you can use to step through your code slowly, line-by-line and see information about all the surrounding variables on any given line.

## Get good at googling

I briefly touched on this when discussing debugging above, but Google (or your search engine of choice) is going to be your best friend as a developer. I search for things **constantly** every single day.

- I have an error in my code? "Copy/paste" the error into google because someone else has probably also had that same problem.
- I don't have an error, but my code isn't doing what I expect it to do? Type that problem into google. Again, someone else has probably had a similar problem and you can quickly find a solution.
- I don't know how to use a library I need for my project? Google that library and read the documentation on how to use it.
- I don't even know what library I might need to solve my problem? Google the problem I'm trying to solve and there's probably a good suggestion for which library to use.
- I forgot how to structure the syntax of some code component? Google that problem. There will be a short tutorial answering your question.
- I want to figure out what is the best web framework for my use case? Google that exact question and read blog posts comparing the top web frameworks.

Learning how to google is an invaluable skill. With practice you'll get better at framing your questions to get the results you want. Any problem or question you have, first reach to google because the answer is probably in the first few links. Only once you have exhausted your google searching should you reach out for help by posting your question in a forum like "stack overflow" or in your social media group.

## Find a mentor

This one is not a "must" in your coding journey, but it is definitely helpful. Find someone to talk to who has already done all this and made it out the other side. It can be very nice to get the perspective of someone in the field, especially if they are in the area of software development that you want to get into (ie web development, phone app development, game development, etc.). Show them your "learning game plan" and see if they have any tips for additions or alterations. Set up regular meetings to check in with them to keep yourself on track. This has the added benefit of giving yourself some accountability. "I don't want to disappoint my mentor by not putting in the work." And finally, ask them for help if you are ever really stuck on a problem.

## Immerse yourself in the jargon

There is *a lot* of jargon (and acronyms) in the software world. "APIs", "SaaS", "Object oriented design", "devops", "CI/CD", "frameworks", "version control", "cloud architecture", "product management", the list goes on and on. üò¶ You've heard a lot of jargon from me in this article, and I'm trying to keep the jargon to a minimum to make the article more understandable. Over time, you need to familiarize yourself with that jargon because you're going to need to understand it (and speak it) in everyday life as a professional software developer. This is not going to happen over night. How can you speed up that process? Immerse yourself in the jargon.

One of the best ways I can think of to immerse yourself in the jargon is through programming podcasts. There are so many good ones out there. I recommend typing "{insert your coding language} podcast" into google and see what comes up. Pick one or 2 podcasts about your language-of-choice and maybe a couple general coding podcasts and listen to them regularly. In no time you'll be hearing that jargon all the time and it'll start making sense. Furthermore, you'll probably learn a lot about what all there is to learn in the world of coding, and you might get some good ideas for updates to your coding game plane. I'll list some of *my* favorite coding podcasts in the section "[self-education resources](#self-education-resources".

## Build a capstone project (or a couple of them)

A capstone project as far as I'm concerned is just a large project that you build yourself to show off the coding skills you've learned. It might be a website, a mobile app, a video game, a dashboard, a desktop app or anything else you can think of. Building one or more capstone projects is really important as they show that you are able to think up, design/architect, build, and deploy a working product all by yourself. These projects are the greatest signal to potential employers that you know the skills you say you know, and they are instrumental in getting hired as a first time junior developer.

One of my first capstone projects a video game called [Twisted Towers](https://verdantfox.com/games/twisted-towers). I also built a stock tracking website (that I sadly don't have a page for anymore) and a couple other smaller applications. I eventually I packaged all these projects up into my portfolio website to share with potential employers.

## Write code for your current job

Whatever your current job is, it uses technology. Look for opportunities to use your new coding skills in your current job. Is there a task you do on the computer that could be automated? Could you write code that analyzes some aspect of your job? If you can't think of any useful project you could create for your work, maybe your boss or co-workers have ideas. Ask around. Writing code for your current job is a great opportunity for three reasons.

1. It is another opportunity to learn. Solving real world problems with code is an awesome way to learn new skills and to get better at skills you've already learned.
2. It will improve your current job. Solving a problem at work with code could save you, your co-workers or your boss tons of time. It'll either make your life easier or it'll make someone else very thankful for you.
3. It looks really good on your resume. First, it's another project you can add to your resume. The more projects, the better. Second, **it allows you to say that you coded for your job.** It might sound like nothing because you solved a small problem, but it means your job listed on your resume went from completely unrelated to your new career to highly relevant to your new career. Potential employers will take stock and they will appreciate your initiative.

## Create a profile website

You learned the things and used your new knowledge to made a couple cool projects. Now you need to show them off. One thing you can do is link to those projects, hosted on GitHub, on your resume. Even better though would be to create a portfolio website. A portfolio website is a website that you will link to from your resume. In it you'll want to talk about yourself. What coding language or languages are you focusing on? What skills, frameworks and tech stacks have you learned? What projects have you built? What open-source projects have you contributed to?

If your coding focus is web-based (front-end, back-end or full-stack) this is the perfect chance to show off what you've learned in the form of a really cool portfolio website built in your tech stack. In fact, this might be your greatest capstone project. Pull out all the stops and make it beautiful and interactive. Perhaps you can build projects you've worked on into the website. Projects that you can't build into the website, you should still include as part of the website. In this case, take lots of screenshots of the projects and describe them in detail.

Even if your coding focus is *not* web-based, still make a portfolio website. In this case, use a website building platform or framework like [WordPress](https://wordpress.com/){: target="_blank", rel="noopener noreferrer" } or [SquareSpace](https://www.squarespace.com/){: target="_blank", rel="noopener noreferrer" } or [Wix](https://www.wix.com/){: target="_blank", rel="noopener noreferrer" } to do the heavy-lifting of designing the website components for you. These platforms offer the ability to create a website without any coding on the front-end or back-end.

Portfolio website's are not something that all coders create, but they have become increasingly popular. They help you stand out against applicants who don't have a portfolio website. They are a nice-looking place to talk about yourself more in depth, and most importantly they are a good place to show off your projects which can be hard to show off appropriately in a resume or through GitHub links.

Before designing your own portfolio website, get inspiration from others. [Feel free to use this website as an example](https://verdantfox.com/){: target="_blank", rel="noopener noreferrer" }. And take a look at a host of others. Try typing "example coding portfolio websites" into google. You'll get a lot of hits. Here's a blog post from that very search that came up from [freeCodeCamp](https://www.freecodecamp.org/){: target="_blank", rel="noopener noreferrer" } called "[15 Web Developer Portfolios to Inspire You](https://www.freecodecamp.org/news/15-web-developer-portfolios-to-inspire-you-137fb1743cae/){: target="_blank", rel="noopener noreferrer" }".

## Write a coding blog

I highly recommend starting a coding blog -- that is -- a blog where you write about concepts you've learned while coding. This is something that I didn't start doing until last year, but it is something I wish I had started when I was first learning to code. Just write about anything and everything you want that you're learning about. Don't worry if someone else has already written about that topic. Writing a coding blog serves 4 purposes.

1. In order to explain a topic to someone else you have to truly understand that topic. Your understanding of the code will improve dramatically for everything you write about.
2. It's valuable to other novice coders. You are will be writing from the perspective of someone just learning to code. You can talk about topics in a way that is understandable and connects with other novice coders. Chances are, if you are learning this topic for the first time, someone else is too (or will be soon) and they might appreciate your explanations.
3. It's valuable to *you* later. I tend to write about topics that are interesting or important to my coding goals. Then later on I forgot key details of things I wrote about. I read my own blog posts all the time to remind myself how to do things.
4. It looks good to employers. Having a blog shows dedication to your studies. It also shows that you have an authoritative grasp of topics.

Don't worry about hosting your blog on the same website as your portfolio. If you want the added challenge, go for it, but it's not really necessary. You can publish your blog posts directly for free to a site like [medium](https://medium.com/creators){: target="_blank", rel="noopener noreferrer" }. Or you can host the blog on a website built with [WordPress](https://wordpress.com/create-blog/){: target="_blank", rel="noopener noreferrer" } or [SquareSpace](https://www.squarespace.com/websites/create-a-blog){: target="_blank", rel="noopener noreferrer" } or [Wix](https://www.wix.com/html5us/hiker-blog){: target="_blank", rel="noopener noreferrer" } that'll make the setup and hosting super easy.

Don't worry about how much traffic your blog gets. You're building it for *you*. Successful blogs are built from passion. If gaining a following is something you desire, [there are plenty of articles out there on how to achieve it](https://memberpress.com/blog/how-to-gain-a-blog-following/){: target="_blank", rel="noopener noreferrer" }, but generally it's going to take a lot of time and consistent posting, so don't stress about it. You'll still get a lot of value from your blog even if your reader count is very low at first.

## Make a LinkedIn account

Software development is a field where [LinkedIn](https://www.linkedin.com/){: target="_blank", rel="noopener noreferrer" } can play a large role in career networking and hiring. Potential employers might want to look at your LinkedIn profile. Recruiters might scout your profile and might work with you to get hired on at companies. Your LinkedIn profile can be an opportunity to go into more depth about yourself, your skills, and your projects than your resume. If you don't already have one, create a LinkedIn for yourself. Add your work history, projects you've worked on, and coding skills, technologies and frameworks you've learned to your LinkedIn profile. Update that profile as you learn more things. Share your LinkedIn page with other people as you career network and add theirs in turn. And don't forget to add a link to your LinkedIn profile in your resume.

## Prepare a resume

Your resume is very important for getting hired. You need to write a resume that is an asset in your job hunt rather than a liability. Take your time to read articles on [how to write an effective resume for a career change](https://online.wharton.upenn.edu/blog/how-to-write-a-career-change-resume/){: target="_blank", rel="noopener noreferrer" }. It might even be a good idea to hire a resume writer to help you craft one that is gold. In any case, thoroughly proofread and have someone else read over your resume as well. Here are some tips for writing a resume to land a job as a first time junior developer.

- **Summarize your skills**: List out the skills that you've learned during your studies. Add bullet points talking up *how* you've used those skills in projects.
- **Highlight your education**: This one can go hand-in-hand with the skills. List some of the more notable courses you took and add any certificates you achieved along the way.
- **Highlight your projects**: List out those capstone projects you worked so hard on. Add details about what technologies you used to create them.
- **Highlight relevant work experience**: Because you're changing fields, much of your work experience will not be relevant to software development. Be brief when discussing positions that don't relate to software development. If you did any coding for any of your jobs, highlight that coding over anything else you did in the job, even if it was a fraction of your work time. Also, talk about soft-skills that you used that are relevant to all jobs like leadership, delegation and crises management.

## Start career networking

Landing your first job as a junior developer is **hard**. You don't yet have a track record as a software developer so it is extra difficult to get potential employers to notice your resume and to trust you to be a good investment for them. You'll probably apply to a *lot* of companies directly and not hear back from many of them. One of the best ways to get your foot in the door with your first company is by career networking. This is something you should start doing well before you are actually actively applying for that first job. Get an early version of your resume and LinkedIn account updated in preparation.

Then start talking to people. Anyone and everyone. Talk about your code-learning journey. Talk about the awesome projects you've built. Show them your portfolio website. Ask if their company is hiring junior developers or if they have any tips for other companies that are hiring. If they are a developer, ask them about what they do in their job. Ask how they got started in the business. See if they have any tips for you. I know this can feel awkward. But it is such a good way to get your foot in the door at a company. If you are talking to someone in person, you are building a connection. People who know you or who get to know you through interactions like these are much more likely to want to help you succeed in you employment goals than someone who has never met you seeing your resume as one faceless resume in their large stack of resumes. Someone like this is more likely to put in a good word for you with someone who can actually hire you so you and your resume can actually be seen and heard.

Here are some great opportunities for networking:

- **Go to coding meetup groups**: look on [meetup.com](https://www.meetup.com/){: target="_blank", rel="noopener noreferrer" } for coding meetup groups in your area. Try searching for "code" or "coding", your chosen coding language (ie "python" or "javascript), frameworks in your coding stack (ie "react" or "angular"), and your area of focus (ie "web development" or "data engineering"). If you are near any major cities there are probably several such meetup groups available. Try attending a couple of events from these groups. Go on a regular basis to build those strong connections.
- **Attend a coding convention**: This one might not be viable for everyone since attending a convention can get pretty pricey between the ticket price, potential plane ticket, and a hotel. But if you are able to attend a coding convention, it can be another great opportunity for networking. This is a place with a lot of people, most of whom have jobs doing what you want to do. There will probably be lots of opportunities to talk in the hallways and during meals between presentations. Also, companies often go to conventions *looking for* candidates to hire. There might even be a job fair. Even if you don't get any good leads, attending a convention is something you can talk about with potential employers that shows your dedication to your career change. I attended the PyCon convention just before landing my first junior developer job and it was an awesome experience.
- **Talk with members of your hobby**: Do you play a sport? Do you dance? Are you a part of a book club? Do you play video games with a regular group? Any group setting like these is a great opportunity to network. This is actually how I got the interview that landed me my first job? I swing dance. I was talking to a friend in the dance community who is a software engineer. We got to talking about his coding journey and my code-learning journey. He told me a department next to his was looking for a junior developer. He handed my resume to his colleague and that lead to an interview and my first dev job.
- **Talk with your friends and family**: Family and friends are another great place to network. Tell them about your dreams and what you're doing to achieve them. They might be able to help you out along the way.

## Practice interviewing

You are likely to have much fewer interview opportunities for that first developer role. Therefore, it is important to really make every interview opportunity you do get, count. Interviews for software development positions can be long, multi-step processes. A typical interview process might go something like this:

1. **An initial interview with a hiring manager or team lead**: They'll probably want to learn more about your background and they'll explain what their company is all about. They decide if you make it to the follow-up interviews.
2. **A homework problem**: In my last round of interviewing maybe 1/3 of interviewers gave a homework problem. They'll give a prompt asking you to build a solution to a hypothetical problem. You'll have a couple days to work on it, and then to give them access to the GitHub repository where your solution resides. Generally the problem is relatively small. Spend a few hours over a couple days crafting a well-designed, clean solution. Make sure to clearly document how to use your project and include automated tests with the solution.
3. **Technical interviews**: You will face anywhere from 1-3 technical interviews. Here are some potential technical interviews to look out for.
      - If you did a homework problem, one interview will probably be talking about your problem solution.
      - One interview might be a live-coding interview where, like the homework problem, you will be given a prompt and asked to create a solution in real time with the interviewer. Maybe 2/3 of companies I applied for had some form of live-coding interview.
      - One interview might be where the interviewers ask you general questions about computer science, your language of choice, and your tech stack. Almost all companies I interviewed with had at least some questions about my general coding/computer science knowledge.
4. **Final interview**: Some (not all) companies will do a final interview where you will get a chance to talk to senior management or event the CEO or CTO of the company (if the company is on the smaller side).

Interview times generally last between 1/2 hour to an hour, but sometimes they can be scheduled back-to-back leading to multiple hours of consecutive interviews with different members of the team. At the end of all interviews (even the technical interviews, you'll get a chance to ask the interviewers questions. I suggest you do so. You want to make sure they are a good fit for you as much as you are a good fit for them. How can you prepare for these interviews?

- **Ready your elevator pitch**: Know ahead of time how to describe yourself in a concise way that highlights all the good stuff you've been learning and working on. Write down that elevator pitch and practice it in front of a mirror and in front of your friends or family.
- **Do practice problems**: There are several resources, such as [freeCodeCamp](https://www.freecodecamp.org/learn/coding-interview-prep/){: target="_blank", rel="noopener noreferrer" } that provide practice problems that simulate potential coding interview problems. Time yourself while solving some of these problem and then look at example answers. This will give you a sense of the types of problems you might be asked to solve. Practice like this will take away some of your nerves and help you prioritize what to work on to solve these types of questions quickly.
- **Read up on coding interviews strategy and popular questions**: There are a lot of other articles that give advice about preparing for coding interviews and that give popular interview questions. Here are a couple that I liked while preparing this section:
    - [Coding interview prep (relax, start here)](https://igotanoffer.com/blogs/tech/coding-interview-prep){: target="_blank", rel="noopener noreferrer" }
    - [100+ Coding Interview Questions for Programmers and Software Engineers in 2022](https://codeburst.io/100-coding-interview-questions-for-programmers-b1cf74885fb7){: target="_blank", rel="noopener noreferrer" }
    - [Top 40 Coding Interview Questions You Should Know](https://www.simplilearn.com/coding-interview-questions-article){: target="_blank", rel="noopener noreferrer" }
- **Write down your own questions**: Remember, you're going to want to interview your interviewers. Write down a few questions ahead of time that are important to you. Here are some examples you could use:
    - What technologies does your company use?
    - What type of work would I be doing on the project I'd be assigned to?
    - What role will I have on the team?
    - What's your company's culture look like?
    - How do you feel about the work-life balance at this company?
    - (If it is a startup) What kind of funding does the company have? Will it be around in 3 years?
    - What is the onboarding process like? What are my next steps in the interview process?

## Conclusions

Did you actually read all that? üòØ If so, give yourself a pat on the back. üéâ Taking the time to read through this article shows your dedication to taking charge of your career.

In the article we talked about [why you might want to become a software developer](#why-become-a-software-developer). Then we talked about the [three main paths](#the-three-main-paths-to-becoming-a-software-developer) you can take to become a software developer. All are great options, but the rest of the article talked about how to succeed in the [self-education path](#self-education).

We talked about [choosing your first programming language](#choosing-a-language), [getting started with coding](#getting-started) and [making a learning game plan](#make-yourself-a-learning-game-plan). We talked about [specific subjects you should make sure to learn](#learn-these-critical-topics) and [the resources that can help you learn them](#self-education-resources). We talked about the [importance of learning every day](#code-at-least-15-minutes-every-day) and [learning by actually *writing* code yourself](#learn-by-doing). We talked about some things you should really consider adding to your learning journey like [finding a mentor](#find-a-mentor), [immersing yourself in the jargon](#immerse-yourself-in-the-jargon), [building a capstone project](#build-a-capstone-project-or-a-couple-of-them) (or 2 or 3), [writing code for your current job](#write-code-for-your-current-job), and [creating a profile website](#create-a-profile-website).

Finally we talked about the end game: preparing your [resume](#prepare-a-resume) and [LinkedIn profile](#make-a-linkedin-account), [career networking](#start-career-networking) and [interview practice](#practice-interviewing). Ultimately, with a lot of hard work and a little luck, all of these topics should be enough to take you from no coding experience to landing that first junior developer job.

With this detailed guide, you now have the tools at your disposal to learn to code on your own and land your first junior developer role, all without a formal education or bootcamp. Good luck on your journey. I'd love to hear how it goes and your progress along the way.
