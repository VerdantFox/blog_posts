# How I went from no coding experience to coding for a living in one year (a guide)

tags: Python, career

## Introduction

01_INTRO_PIC

At the start of June 2017, I was a lab technician at the University of Colorado and had no coding experience. A year later, in June of 2018, I started my first job as a full-time software developer. And I've loved my new career choice ever since. In this article, I'll talk about *how* I made that career pivot, and I'll give you some ideas about how you could make a similar career pivot if it interests you.

## Why become a software developer?

I got my degree in Cellular Biology and worked in research labs for the next five years studying diseases like cancer, HIV, and diabetes. My co-workers were awesome. I was doing cool, cutting-edge science. But the pay was not great, and the career advancement opportunities were similarly underwhelming. I was looking for a change to something more lucrative, with better opportunities for advancement. I heard coding might be a fruitful career change. So I looked into it. How can I become a coder? üë®‚Äçüî¨‚û°üë®‚Äçüíª

I transitioned into software development from the sciences, a field I loved. But moving to software development was the best decision I ever made, and I'll never look back. Here are some reasons *I* love software development as a career and why transitioning your career to software development *might* be a good move for you too.

1. **The pay**: This one is obvious. We all work to make money, and software developers make pretty good money. Right now, [glassdoor.com](https://www.glassdoor.com/member/home/index.htm) reports an average base salary for an introductory "Junior Software Developer" in the United States at over $70,000. This initial salary expectation is consistent with my experience. And there is plenty of room for increasing your income as you gain experience. As you learn more, you become more valuable. After 4+ years in the field, my annual salary is six-figures.
2. **Room for career growth**: This one goes alongside pay, but as you gain more experience as a software developer, you will have opportunities to advance in your career. These opportunities include becoming a senior software engineer, a manager, or other higher administrative roles.
3. **In-demand job**: There are tons of companies looking for quality software developers. I won't lie: getting your foot in the door at that first job can be very difficult. But getting future software development jobs is not difficult once you're in and have proven yourself valuable.
4. **It's fun**: I think coding is fun. It's like solving little logic puzzles. And all the while, you are building something awesome.
5. **It's rewarding**: You get to build excellent applications that real people use. You feel great pride when you push out that finished product and see people using it.

## Am I smart enough to code?

The short answer is, **yes, you are**. Before I learned to code, I thought coding was magic. Super smart people wrote complex, arcane words, and my computer does fantastic things. I thought you had to go to school for years and years of intensive struggle to learn these secrets. And even then, only geniuses could understand it. **Wrong!** You do not have to be a genius to learn to code. You do not even have to have above-average intelligence. And you do not need to be a math wiz.

Ultimately, coding can be super simple. If you have a complicated problem, you break it down into smaller problems. For example, to do large task `A`, you solve smaller tasks `B`, `C`, and `D`. And all these smaller problems come down to simple logical statements directing a computer to do things. "computer: print 'hello world", "computer: make this word green", "computer: add these two numbers together".

Yes, at first, you *will* feel out of your depth. I certainly did when I started. Everyone does at first. There is a lot to learn. But learning to code is like learning to dance, play an instrument, or any other skill. You get started by learning the basics. And believe me, you can learn those basics. And once you are comfortable with those, you start learning a little more complicated stuff. But it's not so bad now because you already know those basics. And those skills keep building until you eventually solve those significant, complex problems. But they don't seem so hard anymore. And stuff that used to seem impossibly complicated is now simple. You'll learn it in small, easy-to-understand, digestible chunks. And as concepts layer on top of each other, and as you practice what you learn, things get easier. I promise you: if you have an interest in coding and a drive and passion for learning, **you can learn to code**.

02_CAN_I_CODE_PIC
***Anyone* with a passion for learning can learn to code.**
**[Image by pch.vector](https://www.freepik.com/free-vector/tiny-people-beautiful-flower-garden-inside-female-head-isolated-flat-illustration_11235915.htm) on Freepik.**

## Disclaimers

**I am not selling anything with this blog post.** You'll find no advertisements on this website. Throughout the article, I list some resources (platforms, courses, books, podcasts). I am not sponsored by or associated with any of these products. I just think that they are quality resources that I have used. I wrote this blog post simply because it is the article that would have helped me out when I started my coding journey. The ideas here are not very original‚Äîjust repackaged and concentrated in one place from many sources, including my personal experience and conversations with other developers.

**I understand I am incredibly privileged.** I'm a cis-hetero white man, have never faced poverty, and have a sound support system. I have all the advantages of that privilege, and that perspective likely skews this blog article. However, I genuinely believe that even if you don't enjoy all of those privileges, this blog article can still help you transition *your* career into software development. Consider these resources if you are looking for more support as a minority interested in coding.

- [Women in tech mentoring program](https://women-in-tech.org/mentoring-program/)
- [43 Tech Resources for People of Color: Communities, Job Boards + More](https://learntocodewith.me/posts/poc-tech-resources/)
- [13 organizations that support LGBTQ+ tech workers](https://www.cio.com/article/188771/13-organizations-that-support-lgbtq-tech-workers.html)

## How to use this blog article

When I started writing this blog article, it was just going to be a list of resources I used in my self-education journey to land my first job as a software developer. But it ended up blowing up into a full-on guide for *anyone* to go from knowing nothing about coding to landing their first job as a junior software developer, and it became a lot more detailed in the process. So it is quite *long*, and many of the details won't make sense until you *start* your software development journey. But they still might be helpful to hear as a primer.

So yes, reading the blog article top-to-bottom is okay, and you will get a lot of good stuff out of it. But some of it won't be very meaningful early on, so maybe bookmark it and come back later at different stages of your learning-to-code journey, as some terms and concepts make more sense in your learning context. ü§∑‚Äç‚ôÇÔ∏è Sound good? Let's dive in!

## The three main paths to becoming a software developer

Before we talk about how I learned to code, let's talk about the options *anyone* has to learn to code. If you are looking to transition into software development, there are three main paths to achieve this goal. You could (1) **get a college computer science (CS) degree**, (2) **train with a coding bootcamp**, or (3) **self-educate**. All three routes have strong advantages and disadvantages. The best path for one person might not be the best path for someone else. We'll briefly go over some of those advantages and disadvantages. My sources for these paths include the [*Command Line Heros*](https://www.redhat.com/en/command-line-heroes) podcast episode, ["Becoming a Coder"](https://www.redhat.com/en/command-line-heroes/season-5/becoming-a-coder), the book [*The Complete Software Developer's Career Guide*](https://simpleprogrammer.com/products/careerguide/) by John Sonmez, the [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#learning-to-code-learn-code), [bestcolleges.com](https://www.bestcolleges.com/bootcamps/payment/bootcamp-cost/#comparison), [thinkimpact.com](https://www.thinkimpact.com/average-college-tuition/), and my own experience and conversations I've had with other software developers. After this section, for the remainder of the article, we'll hone in on the route I took, **self-education**. If that's all you're interested in, feel free to skip to the next section, where I talk about *how* I went about self-educating.

03_LEARNING_PIC
**There are three main paths to becoming a software developer.**
**[Image by pikisuperstar](https://www.freepik.com/free-vector/online-tutorials-concept_7915212.htm) on Freepik.**

### College computer science (CS) degree

This is the big one. The most recent [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#learning-to-code-learn-code) found that ~62% of developers learned to code through a college or university. So formal training with a computer science or similar degree is a *very* popular route. And for a good reason. Individuals who earn a CS degree gain a deep understanding of computer theory as well as a deep understanding of code fundamentals. They get a guided program with lots of resources for help. And they get that shiny diploma that employers love, along with networking opportunities like career fairs and internship programs. The downside? It can be costly, both in terms of money and time.

Who is the college CS degree path a good fit for? This path *can* be a good fit for anyone who feels confident about going into software development and has the time and resources to go to school (or back to school). I think it is a perfect fit for individuals with no previous college degree since having any college degree can give individuals an advantage over those without one when seeking that first job. It's also a good fit if you want to deeply understand computer theory and fundamentals. However, it might not be a good fit if you don't have the time and money to invest four years of your life with limited to no income.

04_COLLEGE_PIC
**The college CS degree path.**
**[Image by pch.vector](https://www.freepik.com/free-vector/young-people-walking-front-college-university-flat-illustration_12291397.htm) on Freepik.**

Advantages:

- **depth and quality**: A CS degree will give the greatest depth of understanding of how computers work "under the hood". Because of this, someone with a CS degree will likely have a deeper understanding of theoretical and fundamental topics like complex data structures and algorithms. Of course, many employers understand that this doesn't *always* translate to the skill of writing high-quality production code in a real-world job. But in some cases, it might, and it certainly doesn't hurt.
- **guidance**: The plan is laid out before you. You know what classes you need to take to achieve the degree. You have an instructor guiding you through the topics. You have TAs and other students to go to for help when you get stuck.
- **employability**: Some employers just want that CS degree. Certain employers won't even consider candidates without a CS degree, especially without other programming experience at a real job. Having the degree makes getting your foot in the door at a quality company much more straightforward.
- **networking**: Many universities offer programs to assist their students in getting into a career. This assistance might be in the form of career fairs, internship opportunities, or clubs or forums where students have chances to meet with employers.

Disadvantages:

- **cost**: A university education might cost anywhere from $40K to well over $100K over four years, depending on the University and financial aid. Software developer jobs are notoriously lucrative, so you'll be able to pay this back in short order, but as with any degree, there's the risk of dropping out without getting the degree and still having that bill.
- **time**: An average bachelor's degree takes four years as a full-time student. That's a long time. Furthermore, you *aren't working* (at least full-time) during those four years, so you are missing out on income during that time.

### Coding bootcamp

That same [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#learning-to-code-learn-code) found just over 10% of individuals learned to code through a coding bootcamp, but that number seems to be on an upward trend. What is a coding bootcamp? It's an intensive program that lasts anywhere from 4 weeks to several months, where they take individuals with potentially no coding experience and teach them everything they need to know to be a proficient coder in real-world coding jobs. Many specialize in one coding language. They are generally much cheaper than the CS degree route and offer many of the same benefits, like set course schedules with guided classes and lots of help. They also usually help with job networking and placement, so many have very high employment rates after graduation. However, because of their growing popularity and lack of regulations for their programs, a subset of such coding bootcamps are low quality and have poor job placement rates. You'll want to thoroughly research all your bootcamp options before picking the one that's right for you.

Who is the coding bootcamp path a good fit for? Overall, I think training at a coding bootcamp is an excellent option for *any* person wanting to transition their career into coding. It might be a good fit for you if you want to make that transition *quickly*, if you need extra help and accountability, and if you want additional help with networking to get that first job.

05_CODING_BOOTCAMP_PIC
**The coding bootcamp path.**
**[Image by vectorjuice](https://www.freepik.com/free-vector/computer-programming-camp-abstract-concept-illustration_12291318.htm) on Freepik.**

Advantages:

- **time**: This is probably the fastest option to go from no coding experience to landing a coding job. Coding bootcamps can range in time from one month to several months.
- **full or part-time**: While not as flexible as self-education, different coding bootcamps have different time requirements. Most programs are full-time, immersive programs. However, some programs are part-time, in the evenings, so you could work your day job and learn to code nights and weekends.
- **cost**: Coding bootcamps are generally cheaper than universities. A several-month bootcamp will typically cost $10,000-$20,000. On top of that, some coding bootcamps won't charge anything until you land your first coding job. In addition, some offer no money down plans and a money-back guarantee if you don't find a job.
- **guidance**: As with the CS degree, you have a set curriculum and a schedule. You have an instructor guiding you through the topics. You have teachers, TAs, and other students to go to for help when you get stuck.
- **employability**: Some employers are sticklers for that 4-year college CS degree. But *many* employers have come around to the idea of coding bootcamps and will rank them on par with a quality CS degree when hiring new developers.
- **networking**: Coding bootcamps want you to get a job after graduating. Most will facilitate employment networking opportunities and help you land that first job.

Disadvantages:

- **cost**: I put this one in the advantage *and* disadvantage category. While I think coding bootcamps are reasonably priced, they can't touch the low cost of self-education. And in some cases, you might have to foot a hefty bill even if you *don't* land a job.
- **Inconsistent quality**: There are a lot of coding bootcamps out there that are **excellent**. üéâ But there are no regulations around coding bootcamps, and some coding bootcamps are not very good or are even predatory. So do thorough research on any bootcamp before you sign that fine print.

### Self-education

The [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#learning-to-code-learn-code) was a little confusing when determining who is self-educated without the help of a CS degree or a bootcamp. Still, if we assume that the three categories don't significantly overlap, approximately 27% of developers learned via self-education. So what does it mean to be self-educated? The term is a little misleading. You're learning from *someone*. But generally, that learning comes from pre-recorded material outside a program's broader context. It means learning from sources like one-off online courses, books, blogs, podcasts, videos, games, challenges, documentation, other people's code, etc. There is no curriculum set for you, no teacher or TA to ask for help from, and no set of assignments. Because no one provides these things for you, if you choose this route, you'll need to get those things yourself. You'll need to design *your own* curriculum, set *your own* schedule and learning pace, *find* a network of people you can ask for help from (or muddy through yourself), and assign *yourself* topics to learn and projects to build.

Who is this path good for? For one, it might be a good starting path for *anyone*. Because this path is free (or very cheap by comparison), it is very low risk. Anyone thinking about coding might at least *start* on the **self-education** path and see what it is all about. You can always *transition* to a college CS degree or coding bootcamp and be no worse off than when you started. It might also be a good fit for you if you need to keep a full-time job and want to learn coding on the side at times that fit *your* schedule and that match *your* learning pace.

While learning on your own schedule at your own pace can be one of the most significant *advantages* of self-education for some, it can be a huge *disadvantage* for others. It means (1) you have to figure out a curriculum and schedule to get from where you are to where you want to be (not easy when you don't yet know what it is you need to learn), and (2) you have to keep *yourself* accountable to stick that curriculum and schedule. With no one holding you accountable, you might struggle to find the motivation to stay on course. That is to say, **self-education** might not be the best fit for you if you need extra help finding your learning path and staying accountable. It also might not be the best fit for you if you find yourself needing lots of extra help from an authority figure or if you don't like going it alone.

06_SELF_EDUCATION_PIC
**The self-education path.**
**[Image by svstudioart](https://www.freepik.com/free-vector/software-developers-working-script-coding-engineer-character-programming-php-python-javascript-other-languages_14723866.htm) on Freepik.**

Advantages:

- **cost**: This is the cheapest option by far. Depending on the resources you opt to use, expenses can range from 100% *free* to a few hundred dollars. Because costs are so low, this option is also very low risk. There's virtually no financial fallout starting this path and then, later on, deciding coding isn't for you.
- **flexibility**: Learn on your own schedule and at your own pace. This flexibility is a massive advantage if you can't afford to quit your job to go to school or attend a coding bootcamp.

Disadvantages:

- **lack of networking**: There's no institution networking with companies on your behalf. You'll have to put in extra work to do the networking yourself.
- **lack of guidance**: There's no one to tell you what to do and ensure you're doing it right. You'll need to set your own curriculum, check your own work, and seek out your own network of people to help you.
- **lack of accountability**: There's no one making you do your work. If you aren't feeling motivated, you won't do the work you need to do to get to where you want to go.
- **more to prove**: *Some* employers will be skeptical of the quality of self-educated individuals, especially for that first-time job. Some won't even consider an individual who doesn't have a CS degree or coding bootcamp certificate. However, increasingly, more and more employers are becoming open to hiring individuals with no formal training as long as they can prove they know their stuff. Some even think it shows tenacity not to need any hand-holding to get to this level. Either way, you'll have to work harder to prove to that first employer that you're a good fit.

### Education path conclusions

Those are the three main paths you can take to take yourself from no coding experience to landing your first coding job. All paths are viable, and there is no one *best* path. You'll have to decide what sounds best *for you*. Each path has advantages and disadvantages, and you should do more research beyond this article before picking any one path. *I* chose the **self-education** path. It worked out well for me, but it was not easy. There was a lot of difficulty and uncertainty along the way. That **self-education** path is the path we'll be talking about for the rest of this article. But even if you chose another path, I think some topics we'll discuss might be excellent supplements to your coding education journey. And as I mentioned above, you can always *start* down the **self-education** path and then transition to another path later.

## Choosing a language

When it comes to coding, everyone has their favorite language. That makes sense. The language is the thing you use to *express* what it is you want the computer to do. And it's the thing you're working with for hours on end. You want to like it. And there are a *lot* of languages to choose from. So without knowing anything about them, how are you supposed to choose one that is right for *you*?

07_LANGUAGE_CHOICE_PIC
**Choose a language.**
**[Image by svstudioart](https://www.freepik.com/free-vector/programmer-working-web-development-code-engineer-programming-python-php-java-script-computer_14723889.htm) on Freepik.**

### Think about language popularity

I recommend picking one of the more popular languages. The more popular a language is, the more likely it is to have a big community to support you (think more courses, tutorials, and people to talk to). These are the top 10 most popular languages according to the [stack overflow developer's survey](https://survey.stackoverflow.co/2022/#most-popular-technologies-language). I pruned the actual list, removing languages that are more helper languages than full-fledged programming languages. The percentage attached is the percentage of respondents who use that language (out of over 70,000 respondents). Any language on this list would be an excellent choice for a first programming language in terms of popularity. Even if a language you're interested in *isn't* on this list, it still probably has a great community and would be a good pick for a first language.

1. JavaScript (65%)
2. Python (48%)
3. Java (33%)
4. C# (28%)
5. C++ (23%)
6. PHP (20%)
7. C (19%)
8. Go (11%)
9. Rust (9%)
10. Kotlin (9%)

### Consider how easy it is to learn

One thing you might consider when picking a language is how easy that language is to learn. All languages aren't that bad once you get to know them. But some just seem to be easier out the gate. Maybe their syntax is more straightforward, their coding style is simpler, or they do more for you, so you have less to think about. Of course, what makes a coding language "easy" and which languages are easy to learn vs. which languages are hard to learn is *very* subjective. Here's a list from [codingdogo.com](https://www.codingdojo.com/blog/easiest-programming-language-to-learn) for their picks of the top 5 easiest and top 5 most challenging languages to learn. While I have only used a few of the languages on this list, I think these choices are reasonable from my limited experience and from talking to other developers. For *why* the site thinks these are easier and more difficult languages, you'll have to [read their article](https://www.codingdojo.com/blog/easiest-programming-language-to-learn).

Top 5 easiest to learn

1. Python
2. C
3. Ruby
4. Java
5. JavaScript

Top 5 hardest to learn

1. C++
2. Prolog
3. LISP
4. Haskell
5. Malbolge

### Consider language use case

If you have an idea of what *type* of programming you want to do, you might pick a language that is well suited for that job. Specific languages tend to be better suited for particular programming needs. Here's a list of some common programming needs and languages that are well suited for them. This is another subjective topic. Some people might consider other languages better for these jobs than the ones I chose. If that's you, or if your favorite language for a job isn't on my list, don't hate. üòõ I'm sure that's a fantastic choice too.

**Front-end web development (code running in your browser):**

- **JavaScript**: This is the only language in town for this job alongside its spinoffs like **typescript** and the structure and style languages **HTML** and **CSS**.

**Back-end web development (code running on a website server):**

- **Node.js**: This language is the same as **javascript** with some subtle differences that allow it to run on a server. This similarity is nice because you can learn just one language for both front-end and back-end web development (i.e., full-stack web development).
- **Python**: Python is an excellent choice for web development because it offers a host of clean, easy-to-use web frameworks. I'm biased because this is *my* language of choice.
- **PHP**: PHP is a veteran of the back-end web space with many web frameworks and a large community.
- **C#**: The Microsoft programming language has a great community and remarkable, opinionated back-end frameworks.

**Data Science:**

- **Python**: Python is the most popular data-science choice nowadays. It has excellent frameworks for efficiently processing large datasets and for data visualization. It is also the only choice when using certain machine learning frameworks.
- **R**: A language whose primary purpose *is* data science. It is older in the data science community and quite popular.

**Android development:**

- **Kotlin**: Google switched to Kotlin as the official language for Android app programming in 2017. It's simpler than Java, with extensive libraries for Android development.
- **Java**: The original official Android app programming language. It is an extremely established language with a vast community.

**iOS development:**

- **Swift**: Apple launched Swift in 2014 specifically for iOS development. It has been steadily growing in popularity.
- **Objective-C**: The original iOS language. It is still widely used, especially in older, established applications.

**Video game development:**

- **C++**: A very *fast* language, famous for creating game engines and games themselves.
- **C#**: A higher-level language popular in video game scripting.
- **JavaScript**: Very popular in creating games hosted on web browsers and mobile platforms.
- **Java**: A universal language popular for creating games such as Minecraft.

**Embedded systems and IoT:**

- **C++**: It is a relatively low-level language with good library support that makes it a popular language for embedded systems, and it is *fast* when written well.
- **C**: A low-level language that is *fast* and is the language beneath the hood for many other higher-level languages like **Python**. Many embedded systems are written directly in **C**.
- **Python**: with the advent of sub-languages like **micropython** that make Python smaller and fit well with embedded systems, Python has growing popularity in the embedded systems space, mainly because it is often considered an easier language to work with than **C++** or **C**.

### Just pick one and stick with it for a while

Here's the biggest secret when it comes to picking your first language. **It doesn't matter all that much which language you choose first.** All the languages (at least the more popular ones) are pretty good. And in the end, they all do pretty similar things. For the most part, they all have the same components: **grammar**, **types**, **variables**, **loops**, **conditional statements**, **functions**, etc. (if you don't know any of those terms, don't worry about it, there's plenty of time to learn üòâ). Of course, there are some differences in language components and structure (for example, object-oriented languages vs. functional languages). But mostly, the differences come down to grammar subtleties and external helper libraries available to the language. For the most part, **once you learn one language, it becomes straightforward to learn a second language**, and it is easier still to learn a third language.

So don't stress too hard about that first language choice. The most important thing you are learning when first learning to code is how to use all languages' underlying components (the **variables**, **loops**, etc.). I recommend sticking to that first language until you feel comfortable writing in it. At least finish a course and create a project with it. Switching away from that first language too early will distract you from learning those core concepts common to all programming languages.

### Language choice conclusions

To conclude, **any** of the above-listed languages would make an excellent choice as a first programming language. There are plenty of job opportunities for any of the above-listed languages, especially as remote work becomes more popular. So consider the language's popularity and your use case. But in the end, the choice doesn't matter as much as you think. Just pick one and stick to it so you can learn the underlying tools common to all programming languages. Once you understand the fundamentals common to all programming languages, it'll be easy enough to switch languages later on.

I picked Python. It is very popular and pretty to look at with a simple-to-learn style. It can handle complex projects, has a wide range of jobs it's good at, and has a great community. But you might choose JavaScript because you want to learn how to make awesome front-end web applications, or you might select Swift because you are interested in creating iPhone apps. So just do a little research and pick one. And whatever you choose, don't stress. They're all excellent, and you can always change your mind later.

## Getting started

Okay, you've decided you will start your coding **self-education** journey, and you've picked a programming language. Where do we go from there? The options are overwhelming. How do you even get started? My best advice here is **just do *something***.

It is *really* hard to know what learning path is right for you when you are first starting. So I recommend just code *something* to begin learning what is suitable for you. The more you code, the more you'll know what works for you. You're never going to have a perfect lesson plan out the gate. Promise yourself right now, "I'm going to spend an hour coding on 'X' platform." It doesn't really matter what resource you are using to code. The hardest part is breaking that deadlock in your mind and deciding you're going to code *something*.

Code for an hour. At the end of that hour, re-evaluate. Maybe you choose to keep doing what you were doing‚Äîthe course you are taking or the coding game you are playing is exciting, and you want to keep exploring it. Then check in after another hour. Maybe you decide to take a break today, but tomorrow, for your next coding hour, you have something new to research based on what you learned coding during that hour. It's cheesy but true: "A journey of a thousand miles begins with a single step." Take that first step, and every step after that will be easier.

08_GETTING_STARTED_PIC
**Get started. Code *something*!**
**[Image by pch.vector](https://www.freepik.com/free-vector/team-starting-project_7416581.htm) on Freepik.**

Start doing *something*? Teddy, that's pretty vague. Do you have any more specific suggestions? Sure. Here are a few resources that would be an excellent get-your-toes-wet introduction to coding.

- [Codecademy](https://www.codecademy.com/learn): This fantastic website offers coding classes in the browser. You can take interactive courses in languages like **Python**, **JavaScript**, **Java**, and various others. Create a free account, pick a language, and start taking that introductory class.
- [FreeCodeCamp](https://www.freecodecamp.org/learn): This is another similar awesome website that offers a variety of free interactive courses you can take directly on their website.
- [Code Combat](https://codecombat.com/): Video games more your speed? This is an excellent website where you learn to code while playing a dungeon crawler video game. Type code commands to move your hero through dangerous dungeons and slay your foes. Unfortunately, you'll have to buy a subscription if you progress far enough.
- [General Assembly course](https://dash.generalassemb.ly/): General Assembly is a company that offers classes, many of which are live, most of which cost money. However, they have an excellent introduction to web development course that is on-demand and free.

Those are just a few resources I've tried and think are perfect for getting your feet wet with programming. And you don't have to finish any of them to get value. Starting an interactive course or game will get you on that path to learning and get you excited to learn more! In addition, it'll give you more information about what steps you need to take along your coding journey.

09_CODE_COMBAT_PIC
**Code Combat gameplay**

## Make yourself a learning game plan

You did it! You coded *something*! üéâ Congratulations! Even if it was an hour (even 15 minutes) taking an interactive class or playing a coding video game, getting started coding *something* is one of the most challenging and critical mental hurdles to get through, and you should be proud of it. So pat yourself on the back. Feel free to linger on that step. Finish that course or coding video game if you like. It's worth it. Once ready, let's start making a learning game plan (or a learning curriculum) for the long journey ahead. Our end goal? Become a proficient coder and get hired as a junior developer.

That curriculum is going to look different for everyone. It will depend on what area you want to go into (web development, smartphone app development, data science, etc.). It will depend on your chosen coding language (Python, JavaScript, C#, etc.). It will depend on your learning style (do you prefer online courses, reading books, etc.)‚ÄîI recommend trying a combination of styles. And it will depend on what pace you feel comfortable with (some topics might be easy, others might require lingering on until you understand them).

Below I'll list some considerations you should make as you design a game plan.

### Keep it fluid

At first, try writing a broad outline of the steps you need to take to get from where you are now to where you want to be (presumably hired as a junior developer). Write these high-level goals in a google doc or spreadsheet. When writing your learning game plan, you aren't going to know what you don't know, especially at first. Make the plan **specific** for goals you want to accomplish soon and **vague** for goals you want to achieve in the distant future. Then as you move forward, fill in the details. As you learn more, keep updating the plan. As you learn new concepts, check back on your game plan and update it to fit your new mental model.

### Write achievable, measurable goals and timelines

Try to be as specific as possible when writing your goals, especially those you want to achieve soon. Each goal should be achievable and measurable. For example, "Complete 'X' Udemy course", "Finish reading 'Y' book", or "Finish 'Z' project and present it to my family". Then attach timelines to those goals. For example, "Complete 'X' Udemy course -- 1 week", "Finish reading 'Y' book -- 2 weeks, "Finish 'Z' project and present it to my family -- 4 weeks". If it works better for you, you can assign dates instead of time periods‚Äîfor example, "Complete 'X' Udemy course by October 1st. By setting achievable, measurable goals, you're setting yourself up for success in making progress on those goals. Likewise, by setting feasible timelines for your goals, you're helping to motivate yourself to get those goals done promptly.

10_LEARNING_GAMEPLAN_PIC
**Create a learning game plan.**
**[Image by vectorjuice](https://www.freepik.com/free-vector/project-management-business-process-planning-workflow-organization-colleagues-working-together-teamwork_11669308.htm) on Freepik.**

### Break down bigger goals into smaller goals in your schedule

Either in the same "Game plan" document or a daily schedule, break down your goals into weekly and daily goals. For example, from our goal "Complete 'X' Udemy course - 1 week", our weekly goal would probably still be "Complete 'X' Udemy course", and we might break down a daily goal for Monday of "Complete sections 'A' and 'B' of 'X' Udemy course". For the goal "Finish reading 'Y' book -- 2 weeks", we might break down to a weekly goal of "Finish chapters 1-12 of book 'Y'" and further break down Tuesday's daily goal to "read chapters 1-3 of book 'Y'". For the goal "Finish 'Z' project and present it to my family -- 4 weeks", we might break that down to a weekly goal of "write the logic for moving and battling". We might further break down our daily goal for Thursday: "Write the game logic for making the enemies chase our hero" (that one got more specific than the other examples üòÜ). Try to check off these daily goals every day. Then at the end of each week, examine how you did this week. Were you good about accomplishing your weekly and daily goals? Are you on track for your big-picture goals? It's okay if you're not but adjust accordingly.

### An example curriculum (what I did)

This example curriculum (or learning game plan) mirrors what I did while learning to code. I made some changes to make the plan fit more closely with what I would have done in retrospect, knowing what I know now. I also made up the timeline‚ÄîI don't remember the exact dates. In the [self-education resources](#self-education-resources) section, I discuss the specific resources used in this plan.

> - free - Take course [CS50X from Edx](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x) to get computer science fundamentals down. - 12 weeks
> - free - [Familiarize yourself with git commands](https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control) - 1 day
> - free - [while taking CS50X] Start listening to programming podcasts in spare time (during commutes, while doing chores or exercising, etc.) - forever
> - ~$25 - Take Udemy course [Learn Python Programming Masterclass](https://www.udemy.com/course/python-the-complete-python-developer-course/) to learn Python in detail. Also, learn topics like object-oriented programming and interacting with databases via Python. - 4 weeks
> - ~$10 - [while learning python] Read the book [*The Complete Software Developer's Career Guide*](https://simpleprogrammer.com/products/careerguide/) by John Sonmez to learn more about becoming a developer. - 4 weeks
> - free - [while learning python] [Start attending monthly python coding meetup group meetings](https://www.meetup.com/). - 1x every month
> - free - Learn [pygame by YouTube with Sentdex tutorial](https://www.youtube.com/playlist?list=PLQVvvaa0QuDdLkP8MrOXLe_rKuf6r80KO) to learn how to make a python video game. - 1 week
> - free - Write first capstone project, a video game in PyGame with Python. This project helps improve those Python fundamentals. - 4 weeks
> - ~$24 - [while writing first capstone project] Read [*Effective python*](https://effectivepython.com/) by Brett Slatkin to hammer down python skills and pythonic thinking - 4 weeks
> - free - Start writing a coding blog, first article = "how I wrote a game in Pygame with Python" - 2 weeks (\*I did not start a blog until later in my career but wish I had started one about here)
> - free - start doing coding challenges at [HackerRank](https://www.hackerrank.com/) in spare time  - forever
> - ~$18 - Take Udemy course [Python for Data Science and Machine Learning Bootcamp](https://www.udemy.com/course/python-for-data-science-and-machine-learning-bootcamp) to learn data science techniques with python - 2 weeks
> - free - Find a project at work to use Python and data science (I found an opportunity to use my coding to write an application that compared DNA sequences in Excel sheets for the lab I was working in) - 2 weeks
> - ~$18 - Take the Udemy course [Python and Django Full Stack Web Developer Bootcamp](https://www.udemy.com/course/python-and-django-full-stack-web-developer-bootcamp/) to learn Python web development with the Django web framework. - 2 weeks
> - free - Write a capstone project‚Äîa stock trading and personal finance application. This project improves web development skills - 4 weeks
> - ~$29 - [while taking Django Udemy course and writing 2nd capstone project] Read the book [*Python Testing with pytest: Simple, Rapid, Effective, and Scalable*](https://pragprog.com/titles/bopytest2/python-testing-with-pytest-second-edition/) by Brian Okken to learn how to do automated testing with Python and pytest - 4 weeks
> - free - write another blog article, "How to write a Django web app" - 2 weeks
> - free - Write portfolio web app in Django - Use the skills we learned with Django to write an awesome portfolio web app to show potential employers. Include in it our two capstone projects and maybe a couple of smaller projects we made while learning various programming skills. - 4 weeks
> - free - [while writing portfolio web app] Start writing resume and LinkedIn portfolio
> - free - Bump up career networking. Tell everyone about the awesome stuff I've been learning and my projects and how I'm looking for a job - forever
> - free - [while networking] Practice interviewing
> - free - [while networking] Apply for programming jobs in the python space, a couple of jobs every day

This example learning game plan might take approximately nine months to execute, leaving another three months for job applications to land a job by the end of the year. While applying for jobs, you would want to continue your learning path on whatever tools and projects interest you while continuing to aggressively career network and practice your interviewing skills.

Next, we'll talk about how to learn and accomplish the goals of your learning game plan.

## Code at least 15 minutes every day

**Try to code or learn about coding for at least 15 minutes *every day***. More is better, but at least 15 minutes a day is *so* valuable. It's not possible *every single day*; things happen. But it is possible *almost* every day. **Prioritize your commitment to code** like you would brushing your teeth or cooking dinner. You are building unstoppable learning momentum. If you are not consistently learning every day (or at least most days), with no one to hold you accountable, you can easily fall off course and lose motivation. And then it can be hard to get that learning momentum back. Stay the course, stick to your learning game plan (keeping it flexible), and you'll be amazed at how much you can learn quickly, even with a bit of progress every day.

## Learn by doing

This is very important. The best way to learn to code (and many other things in life) is by doing it yourself. **"Practice, practice, practice!"** Later on, we'll talk about some specific learning resources. The resources include courses and books. When you are using these resources **type the code out yourself, line by line**. It is possible to read an entire coding book or take a full course without writing *any* code yourself. **Don't do that!** You will learn the topics 10X better if you write the code yourself.

When an instructor is coding, do not just watch the video! **Code along with them.** Type what they are typing into your own file and run the code yourself. Pause the video and make changes to that code. See how the tweaks you make change the output. If an instructor offers coding assignments, do those. Do not just watch the solutions afterward. After completing a course, create a small project that uses what you learned in that course.

When reading a programming book, **write out the code yourself**. There might be times you are reading where you don't have access to a computer. That's okay. Later on, when you do have access to a computer, write code that uses what you learned from the book. Copy and run examples from the book. Tweak examples and see how the output changes. Create a small script or project that uses concepts taught in the book.

11_LEARN_BY_DOING_PIC
**Code at least 15 minutes per day. Learn by doing!**
**[Image by storyset](https://www.freepik.com/free-vector/code-typing-concept-illustration_10259340.htm) on Freepik.**

Writing your own code while taking a course or reading a book *will* slow down that course or book. *That is okay!* It's worth it. The upfront cost of taking the time to write out the code yourself will pay dividends in learning retention. Furthermore, creating scripts and side projects outside of the context of a course will pay off immensely in terms of your understanding of code.

## Learn these critical topics

What kinds of things should you include in your learning game plan? In the following sections, I'll talk about some things you should probably have in any game plan, regardless of language and the area of interest you want to pursue.

### Hello World

The first thing you'll need to learn when learning any programming language is "Hello World". You need to know how to make the simplest code possible that outputs something. Typically, teachers will have you print the words "Hello World" to the screen. This action is your introduction to your new coding language. If you went through [getting started](#getting-started) above, you probably already wrote your "Hello world" code. Congratulations, check that one off the list! üòÉ

### Your language's core components

When learning your first language, you'll need to learn your language's core components. These are things that all programming languages have in common (give or take some minor variations). I'll list some of those core components below. Of course, you won't know any of these yet if you are new to programming. But they are not so difficult to learn. Luckily, if you are taking a course or reading a book meant to teach your language to beginners, that course or book should always cover these components and how to use them. Soon you will be an expert at wielding these core components to get a computer to do tasks for you. The core components include:

- **Variables**: These are words that store data to be used later on.
- **Data types**: These are *what* type of data is stored. They include numbers, words, or phrases (called strings in coding), `true` or `false` keywords (called booleans in coding), and more complex types in the form of data structures.
- **Data structures**: These are *how* complex data is stored. These are things like ("lists" or "arrays"), "sets", ("dictionaries", "maps", or "hashes"), ("objects" or "structs"), and many others. Different data structures are optimal for solving different problems.
- **Operators**: These are things like `+`, `-`, `*`, `/`, `>`, `<` that can be used to compare and manipulate data.
- **Control flow**: These are things like "if/else/then" statements and "loops" that direct the flow of logic for a program.
- **Functions**: These are ways to store chunks of code so the code can be reused without being re-written.
- **Classes**: Not all programming languages have classes. They are specific to **object-oriented** programming languages. But even if your language of choice doesn't use them, they are worth learning about.

### Object-oriented, functional, and procedural designs

There are three main designs (or styles) of coding. Specific languages *require* one of these coding styles. Other languages can use a combination of styles based on preference. I'll review the coding styles briefly, but you should dive deeper into these topics in your studies. If these explanations don't make sense now, that's okay. They will make more sense when you learn them for real on your coding journey.

- **Object-oriented**: In this coding style, all things are "objects". Objects are created by initializing a "class". For example, we could have an `Animal` class (notice capitalization). We would use this `Animal` class to initialize an `animal` (non-capitalized) object. This might look like `tigger = Animal()`. Here, my cat `tigger` is an "object" derived from the `Animal` class. He might have "attributes" associated with him like `tigger.has_fur` which would be `true`. And he might have "methods" associated with him like `talk()` which might do something when called, like print "meow" to the screen.
- **Functional**: This coding style usually has no classes or objects. Instead, data is passed from function to function to achieve a goal.
- **Procedural**: In this coding style, the code is written and run top-to-bottom without including functions or classes. This is a more primitive coding style, but it can still be useful, especially in small scripts.

12_LEARN_THIS_PIC
**Learn these topics.**
**[Image by pch.vector](https://www.freepik.com/free-vector/group-students-watching-online-webinar_8271020.htm) on Freepik.**

### Advanced topics

Here are a few advanced topics you will probably want to learn about on your coding journey, along with brief descriptions. You might not need to understand *all* of these topics on a deep level, but you should at least understand all of them at the surface level, and you might choose to deep-dive into some of them.

- **Recursion**: These are instances where functions call themselves
- **Pointers**: These are things that "point" to the place in your computer's physical memory space where a variable or object from your code resides.
- **Memory management**: How do you handle the memory your code uses? Some languages do this for you; others make you do it yourself.
- **Asynchronous code**: This is code that does more than one thing simultaneously (sort of).
- **Cybersecurity**: How to write safe and secure code.

### Peripheral topics

It would help if you learned some peripheral topics based on your coding focus area. Here are some topics you might want to have a firm understanding of early on in your coding journey.

- **How binary works**: Learn how the binary system works and why it's so important to computer programming.
- **IP Address assignment**: Learn your computer's IP address and how it gets assigned.
- **How the internet works**: Learn what happens when you hit "send" on a web page form. Where does your data go, how does it get there, and how do you get a response back?

### Source control (or version control)

Let's say you're writing code for a website. You save the code files you wrote to your hard drive. Now, let's say you make some changes to those files, adding a new feature. You write your changes and then save your files again *overwriting* those old files. But shoot, the website breaks when you deploy the changes. You want to go back to the previous website version where things were working, but you can't because you overwrote those old files. So now you have to spend a lot of time trying to figure out how things worked when your website worked. Meanwhile, your website continues to be offline. This is a problem.

One solution is to save a new file version for each change. For example, maybe we have `my_website_1,` and for the following change, you make `my_website_2`. That way, if `my_website_2` breaks the website, you can fall back to `my_website_1`. But now you are accumulating many files you need to keep track of. And let's say you give someone else the code because they also want to make changes. But their changes conflict with your changes. So now, who's `my_website` file do we use? This system becomes a mess very quickly.

Source control (also called version control) solves these problems. There are a few source control systems, but the main one used today is called **git**. How does git work? Code gets stored in a central **repository**. When someone wants to make changes, they pull that code down to their system. First, they make their changes locally, and then they push their local changes up to the central repository. The updates they pushed to the central repository become the official version. Git also keeps track of the history of all the changes made since the repository was created, making it easy to go back to a previous version. Also, if multiple people are working on the same code, git has mechanisms for merging two sets of code that have both made changes.

As a developer, source control will be a super important tool in your tool belt. I recommend learning the basics of using git very early in your coding journey. Git can be complicated for edge use cases, but the basics are straightforward. Once primed on the git basics, store all your code in the cloud in a git repository. The primary cloud git repository is called [GitHub](https://github.com/). Make yourself a GitHub account and start pushing all the code you work on up to repositories associated with your GitHub account. You can choose to make those repositories public or private. The added benefit of having all your code on GitHub is that later on, when you want to share your code with others (say, a potential employer), you can point them to your GitHub account to look at all your fabulous projects. For reference to what that looks like, [check out *my* GitHub account](https://github.com/VerdantFox), where you can see a bunch of code I've written and stored in public GitHub repositories. [I even store these blog posts in a public repository.](https://github.com/VerdantFox/blog_posts)

### (Automated) Testing

As you write your code, you will want to test it. Manual testing is the first type of testing you will learn (out of necessity). It works like this: run your code and observe the output. Did your code do what you wanted it to do? If not, tweak it. Then repeat. Manual testing will always be an essential step in your coding process. *Automated* testing is when you write a set of instructions in the form of code called a test. That test runs your code and then checks the results *for you* to ensure the code is doing what you expect.

Why are automated tests necessary?

1. Once they are in place, automated tests reduce your workload *a lot*. There are so many things to check when running your code. For example, you will want to check how your code runs with different inputs and edge cases. If you are only testing manually, first you have to *remember* all those inputs and edge cases; then you have to input them by hand and  *then* visually observe that the results are as expected. Ultimately it is much faster to write those tests once, so you don't have to re-do that work repeatedly.
2. Your code changes in one area might have unintended consequences for other parts of your code base. The tests you wrote for one part of the code base will quickly uncover bugs from changes made elsewhere, even if you forget to test that other part of your code base manually.
3. Testable code is clean code. Automated testing will force you to write your code in a testable way. You will need to write concise, digestible code that is easier to read and maintain.

13_AUTOMATED_TESTING_PIC
**Learn automated testing.**
**[Image by vectorjuice](https://www.freepik.com/free-vector/digital-technology-search-engine-optimization-website-constructor_11669313.htm) on Freepik.**

Writing automated tests is an essential skill in modern coding. It will make your code much more reliable and make changing your code later much faster because you can rely on your automated tests to catch your bugs. And you know what? I know of many projects that *don't* have automated tests. That means that by knowing this valuable skill yourself, you will have the edge over your competitors that don't have this skill when seeking a job.

### Database basics

Most programming applications have to store data. For example, they might store data about their users, their products, and many other things. The most efficient way to store and retrieve most types of data is in a database. There are two broad categories of databases you might want to know about: *relational databases* and *non-relational databases*.

#### Relational Database

Relational databases are the most popular type of database. They consist of **tables** that store data in a **tabular format**. The data is stored in **rows** and **columns**, much like an Excel or Google Sheets spreadsheet. Developers can link tables with related data to one another. For example, a `products` table could be linked to a `reviews` table such that a set of reviews in the `reviews` table is linked to one product in the `products` table. This relationship between tables is the **relational** part of **relational databases**.

Coders can interact with these **relational databases** with a language called SQL or Structured Query Language. SQL allows coders to **query** the database to retrieve rows from those tables‚Äîor to add new rows, update existing rows, or delete rows. Because SQL is the primary way to interact with relational databases, we sometimes refer to those databases as **SQL databases**. And because these databases are so popular, the ability to write SQL code is a valuable skill to pick up. Therefore, you should learn the basics of relational databases and how to read and write some basic SQL code. You don't need to be an expert in SQL or relational databases to use the databases or to get hired, but it is essential to at least learn the basics.

14_DATABASES_PIC
**Learn database basics.**
**[Image by vectorjuice](https://www.freepik.com/free-vector/big-data-job-concept-illustration_20892140.htm) on Freepik.**

#### Non-relational databases

Some data doesn't easily fit into rows and columns in neat tables. Developers can still store this type of data in a database, but they might store it in a **non-relational database**. Side note: because SQL is so ubiquitous when talking about databases, non-relational databases are also often referred to as **NoSQL databases**. With non-relational databases, instead of storing data in a **table** structure, data is stored in a **document** structure. One of the most popular non-relational databases out there is **MongoDB**. It stores data in **documents** that look like JavaScript objects. If that sounds like gibberish to you right now, that's okay. Another fun fact: this website stores its data in a MongoDB database, including the blog post you are currently reading. üòâ

Because **non-relational databases** are much less popular than **relational databases**, I rank learning them as nice but unnecessary. So, look into **non-relational databases** if it is a topic that interests you in your coding journey. Otherwise, keep in mind that they exist and move on.

### A framework or tech stack

Every language has a set of tools bundled up nicely to make a specific job easier and more efficient. These efficiency tool bundles are called frameworks (or sometimes libraries). A tech stack is a series of frameworks working together to make a problem easier to solve. Let's take an example from web development. Both the front-end code (the code running in the user's browser) and the back-end code (the code running on the web server) probably use frameworks.

The front-end code is probably written in JavaScript. That JavaScript code might use the [react](https://reactjs.org/) **framework**, which has high-level tools for creating and keeping track of front-end components and the state of a web page, so you don't have to write those complicated low-level bits yourself. The back-end code might be written in Python. It might use the [Django](https://www.djangoproject.com/) web **framework** that provides tools for accepting web requests, routing them to the relevant back-end code, and returning appropriate responses. And the website might store its data in a [Postgres](https://www.postgresql.org/) relational database. The react front-end framework, the Django back-end framework, and the Postgres database could be collectively considered the website's **tech stack**.

It is a good idea to pick up a framework for your language of choice and learn it well. Picking a framework is similar to choosing a coding language: you'll want to keep in mind the framework's popularity and what it is suitable for. But also, like picking a programming language, selecting the "right" framework is not as important as you think. Most popular frameworks have a great community, documentation, and job opportunities. And once you understand one framework well, it becomes easy to pick up another one.

So pick all the frameworks and tools you need to make up your "tech stack" and learn each framework and tool in the tech stack thoroughly. Then, use that tech stack to make a significant ["capstone project"](#build-a-capstone-project) (more on capstone projects later). This learning and the associated project will be critical in your quest to get hired.

### Packaging and deploying to production

When you are learning and writing code for a significant skill focus area like web development, android/iOS development, or game development, you will write that code in a development environment. You'll have your code files showing. You'll have your language and helper dependencies installed on your machine. You'll probably type a command in your terminal to run your code *on your device*. But what if you want to give that code or product to someone else? You won't want to tell your product users to "install python, install these dependency packages, then open a terminal and type `run my_app.py`." Instead, you will want to give them a finished product. For a game, that might mean giving them an executable file so that all they have to do is double-click that file, and your game starts up. For a website, that will mean hosting your website on a server so they can reach it by typing in your website's URL.

You will need to learn *how* to package up your code and deploy that code to an environment for your users to consume. This is an important skill to learn and one that potential employers will surely ask you about.

15_DEPLOYMENT_PIC
**Learn to package and deploy your code.**
**[Image by vectorjuice](https://www.freepik.com/free-vector/developers-building-testing-deploying-chatbots-platforms-chatbot-platform-virtual-assistant-development-cross-platform-chatbot-concept_11667671.htm) on Freepik.**

### Collaboration methodologies

Since you chose the **self-education** learning path, you might be mostly going it alone. But once you get hired on at a job, you will work as a team. By learning about some collaboration methodologies, you'll give yourself a head start and sound more knowledgeable to your employers. I'm going to list the most important ones below. Somewhere along your learning journey, google these methodologies and read some Wikipedia articles about how they work.

- **waterfall**
- **agile**
- **kanban**
- **scrum**

## Self-education resources

Here are some of the *types* of resources I think you should be using while learning to code, along with some specific resources I used and enjoyed. Note that since I am a python developer in the web space, these resources tend to skew in that direction, but I'll try to talk about how to find resources that fit your goals as well if you aren't looking in that direction.

### Courses

Online courses will probably be essential resources for you while learning to code. Check out [this blog post that suggests some of the best websites with courses for learning to code](https://mikkegoes.com/best-websites-to-learn-coding/) with reasons why the author likes each of them. I tend to agree with the author's choices. While learning, I took courses from a variety of websites, including [Udemy](https://www.udemy.com/), [Edx](https://www.edx.org/), [freeCodeCamp](https://www.freecodecamp.org/), and [Codecademy](https://www.codecademy.com/learn). There are many fantastic websites out there with great courses to offer. You can find a course for any skill you want to learn. Courses vary wildly in time commitments and quality. When selecting a course, the most important things I look at are "is the course highly rated" and "is it popular"? If the answer to both of those questions is "Yes!" then it's probably a good course.

Here are a couple of courses I took and why I liked them. Except for the first one, they tend to focus on my education path of python and web development. You'll notice I have a preference for the Udemy learning platform. Mostly that's because it's what I found early and got comfortable with. Try a few different platforms to find what works for you.

16_COURSES_PIC
**Learn from online courses.**
**[Image by vectorjuice](https://www.freepik.com/free-vector/internet-lessons-searching-remote-university-educational-programs-online-classes-website-high-school-student-with-magnifying-glass-cartoon-character_12085840.htm) on Freepik.**

- [**CS50X from Edx**](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x): this course is Harvard University's "Introduction to Computer Science" course available for free on the platform Edx. It has been taught by professor David J. Malan for something like 15 years now. He does a fantastic job teaching fundamental computer science topics in a way that is exciting and easy to understand. There are weekly homework assignments that are *challenging* for introductory programmers, but they are all graded by automatic tests and real reviewers. The homework assignments make the learning stick. And there is a great, robust [online community for the class on Facebook](https://www.facebook.com/groups/cs50).
- [**Learn Python Programming Masterclass**](https://www.udemy.com/course/python-the-complete-python-developer-course/): This is a great course offered by Udemy. The instructor teaches Python programming to absolute beginners in a super detailed, organized, yet fun manner with lots of examples and assignments. I've taken other intro classes for various programming languages on Udemy and enjoyed them all. However, make sure to write the code yourself and do the suggested assignments because there are no graded assignments in a Udemy class.
- [**Python for Data Science and Machine Learning Bootcamp**](https://www.udemy.com/course/python-for-data-science-and-machine-learning-bootcamp): This is a fantastic Udemy course for learning data science.
- [**Python and Django Full Stack Web Developer Bootcamp**](https://www.udemy.com/course/python-and-django-full-stack-web-developer-bootcamp/): This is an excellent course for learning python web development in the framework I was interested in. The same instructor teaches it as teaches the data science class above. Sometimes if you find a professor you like, you can take multiple courses from them. Popular instructors tend to teach a lot of different courses. He also teaches a [Flask web framework course](https://www.udemy.com/course/python-and-flask-bootcamp-create-websites-using-flask) that I enjoyed.
- **These [JavaScript](https://www.udemy.com/course/the-complete-javascript-course), [HTML, and CSS](https://www.udemy.com/course/design-and-develop-a-killer-website-with-html5-and-css3) courses on Udemy**: They are both taught by the same author. He is great at explaining concepts to complete beginners and offers great examples and coding challenges.

### Books

If reading is an effective way to learn for you, you should always be reading a code-teaching book. I find good code teaching books in two ways: through recommendations and reading reviews on blogs and Amazon. Here are a few books I read while learning to code (and since being hired) that might be good for you. Again, these books have a slant toward my language of choice‚Äîpython. You'll have to go searching for the books that work for you.

- **[*The Complete Software Developer's Career Guide*](https://simpleprogrammer.com/products/careerguide/) by John Sonmez**: This was a book I picked up early while learning to program and found immensely valuable. This blog article is inspired in large part by this book. John does a great job describing what it takes to become a software developer and to self-educate to achieve that goal, and he has a lot more advice about growing your career *after* getting hired as well.
- **[*Effective python*](https://effectivepython.com/) by Brett Slatkin**: This book teaches python programming concepts for writing best-practice python code. He details ideas and ways of thinking that I didn't get from my introductory python masterclass.
- **[*Python Testing with pytest: Simple, Rapid, Effective, and Scalable*](https://pragprog.com/titles/bopytest2/python-testing-with-pytest-second-edition/) by Brian Okken**: I wanted to learn how to get good at testing my python code. Brian does a superb job teaching the most popular python testing framework, pytest.
- **[*Automate the Boring Stuff with Python*](https://automatetheboringstuff.com/) by Al Sweigart**: This book does a great job teaching python to beginners through a series of practical example projects.

### Code challenges

Coding challenges are great for honing your coding skills through practice with small problems. Generally, challenges are ranked from easy to hard. A given problem will probably take a few minutes to solve. Solutions must pass a series of automated tests to succeed. I highly recommend sprinkling coding challenges into your learning. Spend maybe 10 minutes a day (or once every few days) on coding challenges, and you'll see your coding and problem-solving skills improve quickly. Sites that I've tried out and liked include [HackerRank](https://www.hackerrank.com/) and [Coderbyte](https://www.coderbyte.com/).

### Podcasts

Podcasts are a fantastic way to learn big-picture coding concepts and what is happening in the world of coding. I recommend listening to coding podcasts in your spare time, on your commute, when you do chores or exercise or whenever you might listen to podcasts or audiobooks. Here are some coding podcasts that I like. There is a definite slant towards python podcasts since that's my favorite language. To find a coding podcast specific to your language of choice, try typing that language into the search bar of your podcast player app:

17_PODCASTS_PIC
**Immerse yourself in the jargon with tech podcasts.**
**[Image by vectorjuice](https://www.freepik.com/free-vector/listen-podcasts-abstract-concept-vector-illustration-spare-time-covid2019-quarantine-audio-programmes-educational-podcasts-radio-show-bingelistening-interview-abstract-metaphor_24070868.htm) on Freepik.**

#### General tech/coding podcasts

- **Code Newbie**: This is a ~45 min per episode interview-style podcast where guests explain big-picture coding concepts and how they use them in their job.
- **Junior Developer Toolbox**: This ~45 min per episode podcast stopped airing in 2019, but it's worth listening to older episodes. The premise is a few junior developers talk about their experience in their new roles and what it took to get there.
- **Command Line Heros**: This ~30 min per episode podcast mostly gives a history of computers and technology. How Windows, Mac, and Linux operating systems arose, the history of various programming languages, etc. It has a high production value, and I especially enjoyed the OS wars episodes. You might not learn much about coding, but knowing the history can be helpful for context.
- **Compiler**: This ~30 min per episode podcast by RedHat, the same company that made the "Command Line Heros" podcast, asks and tries to answer questions about the tech industry.
- **IRL**: This ~30 min per episode podcast by Mozilla (the company behind the Firefox browser) talks about how tech affects us in the real world.

#### Language specific coding podcasts

- **Python Bytes**: This ~30 min per episode python podcast offers the top 5 or so news items related to python each week. It's fun and digestible, possibly my favorite coding podcast.
- **Talk Python to Me**: This ~60 min per episode interview-style python podcast talks through some python framework, feature, package, or significant news item with a weekly guest.
- **Real Python**: This ~60 min per episode python podcast features interviews, news, and general information about the language.
- **Syntax Web Development**: This 20-60 min podcast (length varies wildly) talks about web development, primarily focused on front-end stuff with JavaScript, HTML, and CSS. It's pretty fun and informative.

### YouTube Videos

There are a lot of good YouTube videos out there teaching coding. Videos range from concept explanations to multi-video tutorials and everything in between. So if you need to learn a concept, YouTube is not a bad place to look. For example, one YouTuber I like in the python coding space has a channel called [sentdex](https://www.youtube.com/c/sentdex/videos).

### Blogs

There are a ton of coding blogs out there (like this one üòú). Many of them offer great explanations, tutorials, and "awesome lists" (lists of things that are awesome); you name it. I don't follow any specific blog for code-learning. However, when I want to learn a new subject, I'll usually type it into google, and a good blog article is probably the first or second hit.

18_BLOG_PIC
**Blogs are great learning resources.**
**[Image by pch.vector](https://www.freepik.com/free-vector/man-creating-content-blog-woman-reading-book-online_11235681.htm) on Freepik.**

### Documentation

Knowing how to read the documentation for a subject matter is often beneficial if you want to learn a language or framework. However, I don't necessarily recommend going to the documentation as your *introduction* to a new subject most of the time. But you're going to need to be able to look at the documentation to look up things like "what methods are available to a class I want to use?" and "what do the input arguments and output returns to this function look like?".

### Other people's code

Finally, a great way to learn how to *write* good code is to *read* good code. Of course, you'll read good code in tutorials. But it might be helpful for you to look up projects on GitHub that use the package or framework you're interested in and see how other people write code with that package or framework. This way, you can learn best practices and emulate those best practices in your *own* code.

## Learn how to debug and how to handle failure

Inevitably, the code you write will fail to work as expected. This will happen **a lot**. Like **A LOT, A LOT**. These code failures are called **bugs**. The code might give you an **error** or run successfully but not output what you expected. In either case, you are going to want to get good at **debugging**. Debugging is one skill that gets more effortless with more experience. Early in your coding journey, you will run into a code bug that you cannot solve **for hours**. That is okay; do not let the bug defeat you! (that's what the bug wants üêõüòÜ) The answer might be as simple as a missing semi-colon. And there is no better feeling in the world than finally solving that pesky bug plaguing you for hours. üéâ There are things you can do to help you push through the debugging process, including the following.

19_DEBUG_PIC
**Everyone gets code bugs. Learn debugging techniques.**
**[Image by vectorjuice](https://www.freepik.com/free-vector/bug-fixing-software-testing-computer-virus-searching-tool-devops-web-optimization-antivirus-app-magnifier-cogwheel-monitor-design-element_10780274.htm) on Freepik.**

- **google it**: Googling is possibly the most critical skill to learn well as a programmer. Often you can solve your problem by simply typing it into google and clicking the first link in the results. If you see a confusing error, try copying/pasting that error into google. You will probably find your answer quickly.
- **rubber ducking**: Explain the code out loud to an inanimate object (such as a rubber duck). Explaining the code aloud will often lead you to find the source of the problem.
- **ask for help**: If you have a friend, mentor, or study buddy with whom you can show the problem, great! Often, someone else coming at the problem from another perspective can figure it out quickly. If you don't have someone you can show the code to, try posting your code with an explanation of the problem to [stack overflow](https://stackoverflow.com/). Perhaps a stranger can help.
- **write print statements**: One helpful tool when debugging is to add print or log statements near where the error occurred. For example, you might print out nearby variables to see if they contain the values you expect them to.
- **use a debugger**: Learning to use a "debugger" can be very helpful in solving tricky bugs. A debugger is a tool that can slowly step through your code and see information about all the surrounding variables on any given line.

## Get good at googling

I briefly touched on this when discussing debugging above, but Google (or your search engine of choice) is going to be your best friend as a developer. I search for things **constantly** every single day.

- Do I have an error in my code? "Copy/paste" the error into google because someone else has probably also had that same problem.
- I don't have an error, but my code isn't doing what I expect. Type that problem into google. Again, someone else has probably had a similar situation and has a quick solution.
- I don't know how to use the library I need for my project. Google that library and read the documentation on how to use it.
- I don't know what library I might need to solve my problem. Google the problem I'm trying to solve, and there's probably a good suggestion for which library to use.
- I forgot how to structure the syntax of some code components. Google that problem. There will be a short tutorial answering your question.
- I want to determine the best web framework for my use case. Then, google that question and read blog posts comparing the top web frameworks.

20_GOOGLE_PIC
**Google is an invaluable tool.**
**[Image by upklyak](https://www.freepik.com/free-vector/keyword-research-landing-page-keywordist-copywriter-girl-with-laptop-using-tools-services-seo-optimization-content-plan-analysis-social-media-vector-cartoon-line-art-web-banner_24375492.htm) on Freepik.**

Learning how to google is an invaluable skill. With practice, you'll get better at framing your questions to get the desired results. For any problem or question, first, reach out to google because the answer is probably in the first few links. Only once you have exhausted your google searching should you reach out for help by posting your question in a forum like "stack overflow" or in your social media group.

## Find a mentor

This one is not a "must" in your coding journey, but it is helpful. Find someone to talk to who has already done all this and made it out to the other side. It can be very nice to get the perspective of someone in the field, especially if they are in the area of software development that you want to get into (i.e., web development, phone app development, game development, etc.). Show them your "learning game plan" and see if they have any tips for additions or alterations. Set up regular meetings to check in with them to keep yourself on track. These check-ins have the added benefit of giving you some accountability. "I don't want to disappoint my mentor by not putting in the work." And finally, reach out to your mentor for help if you are ever really stuck on a problem.

21_MENTOR_PIC
**Find yourself a mentor.**
**[Image by pch.vector](https://www.freepik.com/free-vector/employees-giving-hands-helping-colleagues-walk-upstairs_7732609.htm) on Freepik.**

## Immerse yourself in the jargon

There is *a lot* of jargon (and acronyms) in the software world: "APIs", "SaaS", "Object-oriented design", "DevOps", "CI/CD", "frameworks", "version control", "cloud architecture", "product management", the list goes on and on. üò¶ You've heard a lot of jargon from me in this article, and I'm trying to keep the jargon to a minimum to make the article more understandable. Over time, you need to familiarize yourself with that jargon because you'll need to understand it (and speak it) in everyday life as a professional software developer. Understanding the jargon is not going to happen overnight. How can you speed up that process? Immerse yourself in the jargon.

One of the best ways I can think of to immerse yourself in the jargon is through programming podcasts. There are so many good ones out there. I recommend typing "{insert your coding language} podcast" into google and see what comes up. Then, pick one or two podcasts about your language of choice and maybe a few general coding podcasts and listen to them regularly. In no time, you'll be hearing that jargon all the time, and it'll start making sense. Furthermore, you'll probably learn a lot about what there is to learn in the world of coding, and you might get some good ideas for updates to your coding game plan. I listed some of *my* favorite coding podcasts in the section "[self-education resources](#self-education-resources)".

## Build a capstone project (or a couple of them)

A capstone project is just a large project that you build to show off the coding skills you've learned. It might be a website, a mobile app, a video game, a dashboard, a desktop app, or anything else you can think to build. Building one or more capstone projects is crucial as they show that you can imagine, design, build, and deploy a working product yourself. In addition, these projects are the most significant signal to potential employers that you know the skills you say you do, and they are instrumental in getting hired as a first-time junior developer.

22_CAPSTONE_PROJECT_PIC
**Build a capstone project.**
**[Image by pch.vector](https://www.freepik.com/free-vector/tiny-graphic-designer-drawing-with-big-pen-computer-screen-creators-work-creative-woman-working-laptop-flat-vector-illustration-digital-design-concept-banner-landing-web-page_28480869.htm) on Freepik.**

One of my first capstone projects was a video game called [Twisted Towers](https://verdantfox.com/games/twisted-towers). I also built a stock tracking website (that I sadly don't have a page for anymore) and a couple of other smaller applications. I eventually packaged all these projects into my portfolio website to share with potential employers.

## Write code for your current job

Whatever your current job is, it uses technology. Look for opportunities to use your new coding skills in your current position. Is there a task you do on the computer that you could automate? Could you write code that analyzes some aspect of your job? If you can't think of any worthwhile project you could create for your work, maybe your boss or co-workers have ideas. Ask around. Writing code for your current job is an excellent opportunity for three reasons.

1. It is another opportunity to learn. Solving real-world problems with code is a fantastic way to learn new skills and get better at skills you've already learned.
2. It will improve your current job. Solving a problem at work with code could save you, your co-workers, or your boss tons of time. It'll make your life easier or make someone very thankful for you.
3. It looks terrific on your resume. First, it's another project you can add to your resume. The more projects, the better. Second, **it allows you to say that you coded for your job.** It might sound like nothing because you solved a small problem, but it means the job listed on your resume goes from unrelated to your new career to highly relevant to your new career‚Äîa massive shift. Potential employers will take stock, and they will appreciate your initiative.

## Create a profile website

You learned everything and used your new knowledge to create some cool projects. Now you need to show those projects and skills off. One thing you can do is provide links on your resume to your GitHub-hosted projects. Even better, though, would be to create a portfolio website. A portfolio website is a website you will link to from your resume. In it, you'll want to talk about yourself. What coding language or languages have you learned? What skills, frameworks, and tech stacks have you learned? What projects have you built? Have you contributed to any open source projects?

If your coding focus is web-based (front-end, back-end, or full-stack), this is the perfect chance to show off what you've learned in the form of a fantastic portfolio website built in your tech stack. This portfolio website might be your greatest capstone project. Pull out all the stops and make it beautiful and interactive. Perhaps you can build projects you've worked on *into* the website. Projects that you can't build into the website, you should still include as part of the website. In this case, take many screenshots of the projects and describe them in detail.

Even if your coding focus is *not* web-based, still make a portfolio website. In this case, use a website building platform like [WordPress](https://wordpress.com/), [SquareSpace](https://www.squarespace.com/), or [Wix](https://www.wix.com/) to do the heavy-lifting of building the website components for you. These platforms offer the ability to create a website without needing to code on the front-end or back-end.

23_PORTFOLIO_PIC
**Create a portfolio website.**
**[Image by vector4stock](https://www.freepik.com/free-vector/roof-construction-worker-online-service-platform-building-fixing-house-renovation-rooftop-tile-applying-online-portfolio-flat-vector-illustration_26432967.htm) on Freepik.**

Portfolio websites are not something that all coders create, but they have become increasingly popular. They help you stand out against applicants who don't have a portfolio website. They are a nice-looking place to talk about yourself more in-depth, and most importantly, they are an excellent place to show off your projects which can be hard to show off appropriately in a resume or through GitHub links.

Before designing your portfolio website, get inspiration from others. [Feel free to use my portfolio website as an example](https://verdantfox.com/). Then try typing "example coding portfolio websites" into google. You'll get a lot of hits. Here's a blog post from that search that came up called "[15 Web Developer Portfolios to Inspire You](https://www.freecodecamp.org/news/15-web-developer-portfolios-to-inspire-you-137fb1743cae/)".

## Write a coding blog

I highly recommend starting a coding blog‚Äîthat is‚Äîa blog where you write about concepts you've learned while coding. I didn't begin blogging until last year, but it is something I wish I had started when I was first learning to code. Just write about anything and everything that you're learning. Don't worry if someone else has already written about that topic. Writing a coding blog serves four purposes.

1. To explain a topic to someone else, you have to understand that topic deeply. Therefore, your understanding of the code will improve dramatically for every topic you write about.
2. It's valuable to other novice coders. You can talk about topics in a way other new coders will understand. If you are learning this topic for the first time, someone else is too (or will be soon), and they might appreciate your explanations.
3. It's valuable to *you* later. I tend to write about topics helpful to me. Then, later on, when I forget how to do the things I wrote about, I can re-read my post to remind myself. This happens all the time!
4. It looks good to employers. Having a blog shows dedication to your studies. It also indicates that you have an authoritative grasp of topics.

24_WRITE_BLOG_PIC
**Write a tech blog.**
**[Image by pch.vector](https://www.freepik.com/free-vector/female-writer-using-retro-typing-machine_7732622.htm) on Freepik.**

Don't worry about hosting your blog on the same website as your portfolio. If you want the added challenge, go for it, but it's not necessary and might waste your time. You can publish your blog posts for free on a site like [medium](https://medium.com/creators). Or you can host the blog on a website built with [WordPress](https://wordpress.com/create-blog/), [SquareSpace](https://www.squarespace.com/websites/create-a-blog), or [Wix](https://www.wix.com/html5us/hiker-blog) that'll make the setup and hosting super easy.

Don't worry about how much traffic your blog gets. You're building it for *you*. Successful blogs are created from passion. If gaining a following is something you desire, [there are plenty of articles on how to achieve it](https://memberpress.com/blog/how-to-gain-a-blog-following/), but generally, it's going to take a lot of time and consistent posting, so don't stress about it. You'll still get much value from your blog, even if your reader count is meager initially.

## Make a LinkedIn account

Software development is a field where [LinkedIn](https://www.linkedin.com/) can play a prominent role in career networking and hiring. Potential employers might want to look at your LinkedIn profile. Recruiters might scout your profile and work with you to get hired at companies. Your LinkedIn profile can be an opportunity to go into more depth about yourself, your skills, and your projects than your resume. If you don't already have one, create a LinkedIn account for yourself. Add your work history, projects you've worked on, and coding skills, technologies, and frameworks you've learned to your LinkedIn profile. Update that profile as you learn more things. Share your LinkedIn page with others as you career network and add them as contacts. And don't forget to add a link to your LinkedIn profile in your resume.

25_RESUME_PIC
**Create a LinkedIn account and stellar resume.**
**[Image by vectorjuice](https://www.freepik.com/free-vector/resume-writing-service-abstract-concept_12085270.htm) on Freepik.**

## Prepare a resume

Your resume is essential for getting hired. You want to write a resume that is an asset in your job hunt rather than a liability. Take your time to read articles on [how to write an effective resume for a career change](https://online.wharton.upenn.edu/blog/how-to-write-a-career-change-resume/). Hiring a resume writer to help you craft one that is gold might even be a good idea. In any case, thoroughly proofread (use a tool like [grammarly](https://app.grammarly.com/)) and have someone else read over your resume. Here are some tips for writing a resume to land a job as a first-time junior developer.

- **summarize your skills**: List out the skills that you've learned during your studies. Add bullet points talking up *how* you've used those skills in projects.
- **highlight your education**: This can go hand-in-hand with the skills. List some of the more notable courses you took and add any certificates you achieved along the way.
- **highlight your projects**: List those capstone projects you worked so hard on. Add details about what technologies you used to create them.
- **highlight relevant work experience**: Because you're changing fields, much of your work experience will not apply to software development. So be brief when discussing positions that don't relate to software development. However, if you coded *anything* for your job, **highlight that coding**. Even if it was a small percentage of your job, it was the most relevant work to your *next* job. Finally, discuss soft skills you used in previous employment, like leadership, persistence, and crisis management skills.

## Start career networking

Landing your first job as a junior developer is **hard**. You don't yet have a track record as a software developer, so it is extra challenging to get potential employers to notice your resume and trust that you'll be a good investment. You'll probably apply to a *lot* of companies directly and not hear back from many of them. Career networking is one of the best ways to get your foot in the door with your first company. Career networking is something you should start doing well before you are actively applying for that first job. Get an early version of your resume and LinkedIn account updated in preparation.

Then start talking to people: anyone and everyone. Talk about your code-learning journey and the awesome projects you've built. Show them your portfolio website. Ask if their company is hiring junior developers or if they have any tips for other companies that are hiring. If they are a developer, ask them about what they do in their job. Ask how they got started in the business. See if they have any tips for you.

I know this can feel awkward. But it is an excellent way to get your foot in the door at a company. Talking to people builds connections. People who know you or get to know you through interactions like these are much more likely to help you succeed in your employment goals than people who have never met you and are seeing your resume as one faceless resume in a large stack of other resumes. Someone you connect with is more likely to put in a good word for you with someone who can hire you so your resume can be *seen* and seriously considered.

26_NETWORKING_PIC
**Start career networking.**
**[Image by vectorjuice](https://www.freepik.com/free-vector/successful-partnership-negotiation-partners-handshaking_11669283.htm) on Freepik.**

Here are some great networking opportunities:

- **Go to coding meetup groups**: look on [meetup.com](https://www.meetup.com/) for coding meetup groups in your area. Try searching for "code" or "coding", your chosen coding language (i.e., "python" or "javascript"), frameworks in your coding stack (i.e., "react" or "angular"), and your area of focus (i.e., "web development" or "data engineering"). If you are near any major city, several such meetup groups are probably available. Try attending a couple of events from these groups. Go regularly to build those strong connections.
- **Attend a coding convention**: This one might not be viable for everyone since attending a convention can get pretty pricey between the ticket price, potential plane ticket, and a hotel. But if you can attend a coding convention, it can be another excellent networking opportunity. Coding conventions are places with lots of people, most of whom have jobs doing what you want to do. There will probably be many opportunities to talk in the hallways and during meals between presentations. Also, companies often go to conventions *looking for* candidates to hire. There might even be a job fair. Even if you don't get any promising leads, attending a convention is something you can talk about with potential employers that shows your dedication to your career change. I attended the PyCon convention just before landing my first junior developer job, and it was an incredible experience.
- **Talk with members of your hobby**: Do you play a sport? Dance? Are you a member of a book club? Do you play video games with a regular group? Any group setting like this is an excellent opportunity to network. This is how I got the interview that landed me my first job. I swing dance. I was talking to a friend in the dance community who is a software engineer. We got to talking about his coding journey and my code-learning journey. He told me a department next to his was looking for a junior developer. He handed my resume to his colleague, which led to an interview and my first dev job.
- **Talk with your friends and family**: Friends and family provide valuable networking opportunities. Tell them about your dreams and what you're doing to achieve them. They might be able to help you out along the way.

## Practice interviewing

You will likely have fewer interview opportunities for that first developer role than established developers. Therefore, you must present your best self in every interview you land. Interviews for software development positions can be long, multi-step processes. A typical interview process might go something like this:

1. **An initial interview with a hiring manager or team lead**: They'll probably want to learn more about your background and explain their company. They decide if you make it to the follow-up interviews.
2. **A homework problem**: In my last round of interviews, maybe 1/3 of the companies gave a homework problem. They'll provide a prompt asking you to build a solution to a hypothetical problem. You'll have a couple of days to work on it and then give them access to the GitHub repository where your solution resides. Generally, the problem is relatively small. Spend a few hours crafting a well-designed, clean solution over a couple of days‚Äîdocument how to use your project and include automated tests.
3. **Technical interviews**: You will face anywhere from 1-3 technical interviews. Here are some potential technical interviews to look out for.
      - If you did a homework problem, one interview will probably discuss your problem's solution.
      - One interview might be a live-coding interview. Like the homework problem, you will be given a prompt and asked to create a solution in real time with the interviewer. Maybe 2/3 of the companies I applied for had some form of a live-coding interview.
      - One interview might be where the interviewers ask you general questions about computer science, your language of choice, and your tech stack. Almost all companies I interviewed with had at least some questions about my general coding/computer science knowledge.
4. **Final interview**: Some (not all) companies will do a final interview where you will get a chance to talk to senior management or even the CEO or CTO of the company (if the company is on the smaller side).

27_INTERVIEW_PIC
**Practice interviewing.**
**[Image by vectorjuice](https://www.freepik.com/free-vector/job-interview-process-hiring-new-employees-hr-specialist-cartoon-character-talking-new-candidatee-recruitment-employment-headhunting_10780346.htm) on Freepik.**

Interview times generally last between 1/2 hour to an hour. Annoyingly, sometimes they can be scheduled back-to-back, leading to multiple hours of consecutive interviews with different team members. At the end of all interviews (even the technical interviews), you'll get a chance to ask the interviewers questions. I suggest you do so. You want to make sure they are a good fit for you as much as you are a good fit for them. How can you prepare for these interviews?

- **Ready your elevator pitch**: Know ahead of time how to describe yourself in a concise way that highlights all the good stuff you've been learning and working on. Write down that elevator pitch and practice it in front of a mirror and in front of your friends or family.
- **Do practice problems**: Several resources, such as [freeCodeCamp](https://www.freecodecamp.org/learn/coding-interview-prep/), provide practice problems that simulate potential coding interview problems. Time yourself while solving some of these problems, and then look at example answers. Solving these problems will give you a sense of the types of problems interviewers might ask you to solve. In addition, practice like this will take away some of your nerves and help you prioritize what to work on to solve these questions quickly.
- **Read up on coding interview strategy and popular questions**: Many blog articles give advice about preparing for coding interviews and give popular interview questions. Here are a few such articles that I found while preparing this section:
    - [Coding interview prep (relax, start here)](https://igotanoffer.com/blogs/tech/coding-interview-prep)
    - [100+ Coding Interview Questions for Programmers and Software Engineers in 2022](https://codeburst.io/100-coding-interview-questions-for-programmers-b1cf74885fb7)
    - [Top 40 Coding Interview Questions You Should Know](https://www.simplilearn.com/coding-interview-questions-article)
- **Write down your own questions**: Remember, you will want to interview your interviewers. Write down a few important questions ahead of time. Here are some examples you could use:
    - What technologies does your company use?
    - What project would I be assigned? What type of work will I do on that project?
    - What role will I have on the team?
    - What's your company's culture look like?
    - How do you feel about the work-life balance at this company?
    - (If it is a startup) What kind of funding does the company have? Will it be around in 3 years?
    - What is the onboarding process like? What are my next steps in the interview process?

## Conclusions

Did you actually read all that? üòØ If so, pat yourself on the back. üéâ Taking the time to read this article shows your dedication to taking charge of your career. So what did we discuss in this article?

In the article, we talked about [why you might want to become a software developer](#why-become-a-software-developer). Then we discussed the [three main paths](#the-three-main-paths-to-becoming-a-software-developer) you can take to become a software developer. All are great options, but the rest of the article discussed how to succeed in the [self-education path](#self-education).

We talked about [choosing your first programming language](#choosing-a-language), [getting started with coding](#getting-started) and [making a learning game plan](#make-yourself-a-learning-game-plan). We talked about [specific subjects you should make sure to learn](#learn-these-critical-topics) and [the resources that can help you learn them](#self-education-resources). We talked about the [importance of learning every day](#code-at-least-15-minutes-every-day) and [learning by actually *writing* code yourself](#learn-by-doing). We talked about some things you should really consider adding to your learning journey like [finding a mentor](#find-a-mentor), [immersing yourself in the jargon](#immerse-yourself-in-the-jargon), [building a capstone project](#build-a-capstone-project-or-a-couple-of-them) (or 2 or 3), [writing code for your current job](#write-code-for-your-current-job), and [creating a profile website](#create-a-profile-website).

Finally we talked about the end game: preparing your [resume](#prepare-a-resume) and [LinkedIn profile](#make-a-linkedin-account), [career networking](#start-career-networking) and [interview practice](#practice-interviewing). Ultimately, with a lot of hard work and a little luck, these topics should be enough to take you from no coding experience to landing that first junior developer job.

28_CONCLUSIONS_PIC
**Good luck in your journey!**
**[Image by pch.vector](https://www.freepik.com/free-vector/business-leader-standing-arrow-holding-flag-flat-vector-illustration-cartoon-people-training-doing-business-plan-leadership-victory-challenge-concept_10606192.htm) on Freepik.**

With this detailed guide, you now have the tools at your disposal to learn to code on your own and land your first junior developer role, all without a formal education or coding bootcamp. Good luck on your journey. I'd love to hear how it goes and your progress along the way.

## Attributions

Introduction pic: [Image by macrovector](https://www.freepik.com/free-vector/programmer-work-with-working-day-symbols-flat-illustration_15329611.htm) on Freepik

All other necessary attributions are made at the source.
